{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>ChemSynthCalc stands for Chemical Synthesis Calculator -  a Python 3 package for calculating the masses of substances required for  chemical synthesis directly from the reaction string. It includes solutions for all intermidiate steps:</p> <ul> <li>Chemical formula strings parsing</li> <li>Calculation of molar mass</li> <li>Reaction string parsing and decomposition</li> <li>Creation of reaction matrix</li> <li>Manual reaction balance</li> <li>Automatic reaction balance</li> <li>Masses calculations</li> <li>Output to terminal, as plain txt or JSON (object or file)</li> <li>... and more</li> </ul> <p>..</p>"},{"location":"#main-project-page","title":"Main project page","text":"<p>https://github.com/Syrov-Egor/chemsynthcalc</p>"},{"location":"#background","title":"Background","text":"<p>ChemSynthCalc was created to address the issue of inorganic synthesis calculations. There are three main aspects to this problem. </p> <p>First of all, a single student, scientist, postdoc, etc., sitting in their lab  trying to synthesize a new material. The sample size of potential reactions is quite small in this case,  and our fellow scientist can use the old-fashioned pen and paper method.  But why should one not try to automate this boring task?</p> <p>Secondly, while we are not quite there yet, one can imagine a robotic inorganic synthesis station, like Dr. Cronin devices. In this case, we need to calculate a large number of reactions fast and precisely,  and we really should not hard-code all the masses beforehand.</p> <p>Finally, there are datasets of text-mined inorganic reactions. They will surely expand and grow in size. With a sample size of tens of thousands, we need our reaction balancing software  to be extremely fast, robust, and flexible enough to balance as many reactions as it can.  In this case, we surely need a free open-source solution that can be embedded in the data processing system.</p> <p>ChemSynthCalc addresses all three of those cases. It is simple enough to use for a single scientist who  is familiar with using Python packages and fast and robust enough to precisely  calculate hundreds and thousands of reactions.</p>"},{"location":"#competitive-analysis","title":"Competitive analysis","text":"<p>There are already a large number of reaction balancing software, why do you need chemsynthcalc and why is it better than competitors?</p> <ul> <li>chemsynthcalc is completely free and open-source (under MIT license)</li> <li>chemsynthcalc provides a rich and simple API for its functions</li> <li>chemsynthcalc can balance a huge variety of reactions</li> <li>chemsynthcalc can deal with formulas with float atom count (like RbLa<sub>0.99</sub>Eu<sub>0.01</sub>Nb<sub>2</sub>O<sub>7</sub>), both for molar mass and reaction balancing</li> <li>chemsynthcalc supports an infinite amount of nested parentheses in formulas</li> <li>chemsynthcalc supports adduct notaion (like CuSO<sub>4</sub>*5H<sub>2</sub>O)</li> <li>chemsynthcalc is fast thanks to NumPy matrix operations</li> <li>finally, chemsynthcalc is one of the few programs that can directly output precursor masses from a reaction string (in three lines of code!)</li> </ul> Software Mass calculation Float coefficients and atom amounts API chemsynthcalc \u2713 \u2713 \u2713 WebQC \u2713 x x Equation Balancer x x x ChemicalAid x \u2713 x CHEMIX School x \u2713 x ChemPy x x \u2713 <p>There are two main classes to acesses the functionality: ChemicalFormula and ChemicalReaction. You can check them in the menu.</p>"},{"location":"API/","title":"API reference","text":""},{"location":"API/#chemsynthcalc--chemsynthcalc","title":"chemsynthcalc","text":"<p>Python package for calculating the masses of substances required for chemical synthesis directly from the reaction string. It includes solutions for all intermediate steps, including chemical formula parsing, molar mass calculation and reaction balancing with different matrix methods.</p>"},{"location":"API/#chemsynthcalc--example-use","title":"Example use","text":"<p>Let's say that we need to prepare 3 grams of YBCO by solid-state synthesis from respective carbonates. The reaction string will look something like this (to simplify, let's leave it without oxygen nonstoichiometry):</p> <pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"BaCO3 + Y2(CO3)3 + CuCO3 + O2 \u2192 YBa2Cu3O7 + CO2\"\n</code></pre> <p>Now, we can create a chemical reaction object of the <code>ChemicalReaction</code> class, which will be used in the calculation. We need to specify the arguments for our particular case: <pre><code>&gt;&gt;&gt; reaction = ChemicalReaction(\n    reaction = reaction_string, # our reaction string\n    target = 0, # index of target compound in the product list\n    target_mass = 3, # desired mass of target compound,\n    mode = \"balance\" # mode of coefficients calculations,\n)\n</code></pre></p> <p>Now, to perform the automatic calculation, all we need to do is to put: <pre><code>&gt;&gt;&gt; reaction.print_results(print_rounding_order=4)\n# assuming that we use analytical balances with 4 digit presicion\n</code></pre></p> <p>And we get our output in the terminal: <pre><code>initial reaction: BaCO3+Y2(CO3)3+CuCO3+O2\u2192YBa2Cu3O7+CO2\nreaction matrix:\n [[1. 0. 0. 0. 2. 0.]\n [1. 3. 1. 0. 0. 1.]\n [3. 9. 3. 2. 7. 2.]\n [0. 2. 0. 0. 1. 0.]\n [0. 0. 1. 0. 3. 0.]]\nmode: balance\nformulas: ['BaCO3', 'Y2(CO3)3', 'CuCO3', 'O2', 'YBa2Cu3O7', 'CO2']\ncoefficients: [8, 2, 12, 1, 4, 26]\nnormalized coefficients: [2, 0.5, 3, 0.25, 1, 6.5]\nalgorithm: inverse\nis balanced: True\nfinal reaction: 8BaCO3+2Y2(CO3)3+12CuCO3+O2\u21924YBa2Cu3O7+26CO2\nfinal reaction normalized: 2BaCO3+0.5Y2(CO3)3+3CuCO3+0.25O2\u2192YBa2Cu3O7+6.5CO2\nmolar masses: [197.335, 357.835676, 123.554, 31.998, 666.190838, 44.009]\ntarget: YBa2Cu3O7\nmasses: [1.7773, 0.8057, 1.6692, 0.036, 3.0, 1.2882]\nBaCO3: M = 197.3350 g/mol, m = 1.7773 g\nY2(CO3)3: M = 357.8357 g/mol, m = 0.8057 g\nCuCO3: M = 123.5540 g/mol, m = 1.6692 g\nO2: M = 31.9980 g/mol, m = 0.0360 g\nYBa2Cu3O7: M = 666.1908 g/mol, m = 3.0000 g\nCO2: M = 44.0090 g/mol, m = 1.2882 g\n</code></pre></p>"},{"location":"API/#chemsynthcalc.balancer","title":"<code>balancer</code>","text":""},{"location":"API/#chemsynthcalc.balancer.Balancer","title":"<code>Balancer</code>","text":"<p>               Bases: <code>BalancingAlgorithms</code></p> <p>A class for balancing chemical equations automatically by different matrix methods.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray[float64]</code> <p>Reaction matrix</p> required <code>separator_pos</code> <code>int</code> <p>Position of the reaction separator (usually the separator is \"=\")</p> required <code>round_precision</code> <code>int</code> <p>Coefficients rounding precision</p> required <code>intify</code> <code>bool</code> <p>Determines whether the coefficients should be integers</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>coef_limit</code> <code>int</code> <p>max integer coefficient for         _intify_coefficients method</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>class Balancer(BalancingAlgorithms):\n    \"\"\"\n    A class for balancing chemical equations automatically by different matrix methods.\n\n    Parameters:\n        matrix (npt.NDArray[np.float64]): Reaction matrix\n        separator_pos (int): Position of the reaction separator (usually the separator is \"=\")\n        round_precision (int): Coefficients rounding precision\n        intify (bool): Determines whether the coefficients should be integers\n\n    Attributes:\n        coef_limit (int): max integer coefficient for \\\n        [_intify_coefficients][chemsynthcalc.balancer.Balancer._intify_coefficients] method\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: npt.NDArray[np.float64],\n        separator_pos: int,\n        round_precision: int,\n        intify: bool = True,\n    ) -&gt; None:\n        super().__init__(matrix, separator_pos)\n\n        if round_precision &gt; 0:\n            self.round_precision: int = round_precision\n        else:\n            raise ValueError(\"precision &lt;= 0\")\n\n        self.intify: bool = intify\n        self.coef_limit: int = 1_000_000\n\n    def __str__(self) -&gt; str:\n        return f\"Balancer object for matrix \\n {self.reaction_matrix}\"\n\n    def __repr__(self) -&gt; str:\n        return f\"Balancer({self.reaction_matrix}, {self.separator_pos}, {self.round_precision}, {self.intify})\"\n\n    def _intify_coefficients(\n        self, coefficients: list[float], limit: int\n    ) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        Reduce the coefficients to integers by finding the greatest common divider.\n\n        Parameters:\n            coefficients (list): List of coefficients to intify\n            limit (int): Upper limit (max int coef)\n\n        Returns:\n            A list of intified coefficients\n        \"\"\"\n        initial_coefficients = coefficients\n        frac = [Fraction(x).limit_denominator() for x in coefficients]\n        vals = [\n            int(\n                fr.numerator\n                * find_lcm([fr.denominator for fr in frac])\n                / fr.denominator\n            )\n            for fr in frac\n        ]\n        coefficients = [int(val / find_gcd(vals)) for val in vals]\n        if any(x &gt; limit for x in coefficients):\n            return initial_coefficients\n        return coefficients\n\n    @staticmethod\n    def is_reaction_balanced(\n        reactant_matrix: npt.NDArray[np.float64],\n        product_matrix: npt.NDArray[np.float64],\n        coefficients: list[float] | list[int],\n        tolerance: float = 1e-8,\n    ) -&gt; bool:\n        \"\"\"\n        Checks if reaction is balanced by multiplying reactant matrix and product matrix\n        by the respective coefficient vector. Method is static to call it outside of balancer\n        instance.\n\n        Parameters:\n            reactant_matrix (npt.NDArray[np.float64]): Matrix of reactants property generated by [ChemicalReaction][chemsynthcalc.chemical_reaction.ChemicalReaction] class\n            product_matrix (npt.NDArray[np.float64]): Matrix of products property generated by [ChemicalReaction][chemsynthcalc.chemical_reaction.ChemicalReaction] class\n            coefficients (list[float] | list[int]): Coefficients\n            tolerance (float): tolerance limit for the *np.allclose* function\n\n        Returns:\n            True if balanced within tolerance\n\n        Examples:\n            &gt;&gt;&gt; reaction = ChemicalReaction(\"NH4ClO4+HNO3+HCl=HClO4+NOCl+N2O+N2O3+H2O+Cl2\")\n            &gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [64, 167, 137, 80, 43, 64, 30, 240, 39])\n            True\n            &gt;&gt;&gt; reaction = ChemicalReaction(\"H2+O2=H2O\")\n            &gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [2,2,2])\n            False\n        \"\"\"\n        try:\n            reactants = np.multiply(\n                reactant_matrix.T,\n                np.array(coefficients)[: reactant_matrix.shape[1], None],\n            )\n            products = np.multiply(\n                product_matrix.T,\n                np.array(coefficients)[reactant_matrix.shape[1] :, None],\n            )\n            return np.allclose(\n                reactants.sum(axis=0), products.sum(axis=0), rtol=tolerance\n            )\n\n        except Exception:\n            return False\n\n    def _calculate_by_method(self, method: str) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        Compute the coefficients list by a specific method.\n\n        Parameters:\n            method (str): One of 4 currently implemented methods (inv, gpinv, ppinv, comb)\n\n        Returns:\n            A list of coefficients\n\n        Raise:\n            ValueError if method is not found. &lt;br /&gt;\n            [BalancingError][chemsynthcalc.chem_errors.BalancingError] if can't balance reaction by specified method.\n        \"\"\"\n        match method:\n\n            case \"inv\":\n                coefficients: list[float] = np.round(\n                    self._inv_algorithm(), decimals=self.round_precision\n                ).tolist()  # type: ignore\n\n            case \"gpinv\":\n                coefficients: list[float] = np.round(\n                    self._gpinv_algorithm(), decimals=self.round_precision + 2\n                ).tolist()  # type: ignore\n\n            case \"ppinv\":\n                coefficients: list[float] = np.round(\n                    self._ppinv_algorithm(), decimals=self.round_precision + 2\n                ).tolist()  # type: ignore\n\n            case \"comb\":\n                res: npt.NDArray[np.int32] | None = self._comb_algorithm()\n                if res is not None:\n                    return res.tolist()  # type: ignore\n                else:\n                    raise BalancingError(f\"Can't balance reaction by {method} method\")\n\n            case _:\n                raise ValueError(f\"No method {method}\")\n\n        if (\n            Balancer.is_reaction_balanced(\n                self.reactant_matrix, self.product_matrix, coefficients\n            )\n            and all(x &gt; 0 for x in coefficients)\n            and len(coefficients) == self.reaction_matrix.shape[1]\n        ):\n            if self.intify:\n                intified = self._intify_coefficients(coefficients, self.coef_limit)\n                if all(x &lt; self.coef_limit for x in intified):\n                    return intified\n                else:\n                    return coefficients\n            else:\n                return coefficients\n        else:\n            raise BalancingError(f\"Can't balance reaction by {method} method\")\n\n    def inv(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        A high-level function call to compute coefficients by Thorne method.\n\n        Returns:\n            A list of coefficients\n        \"\"\"\n        return self._calculate_by_method(\"inv\")\n\n    def gpinv(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        A high-level function call to compute coefficients by\n        Risteski general pseudoinverse method.\n\n        Returns:\n            A list of coefficients\n        \"\"\"\n        return self._calculate_by_method(\"gpinv\")\n\n    def ppinv(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        A high-level function call to compute coefficients by\n        Risteski partial pseudoinverse method.\n\n        Returns:\n            A list of coefficients\n        \"\"\"\n        return self._calculate_by_method(\"ppinv\")\n\n    def comb(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        A high-level function call to compute coefficients by\n        combinatorial method.\n\n        Returns:\n            A list of coefficients\n        \"\"\"\n        return self._calculate_by_method(\"comb\")\n\n    def auto(self) -&gt; tuple[list[float | int] | list[int], str]:\n        \"\"\"\n        A high-level function call to automatically compute coefficients\n        by sequentially calling inv, gpinv, ppinv methods.\n\n        Returns:\n            A list of coefficients\n\n        Raise:\n            [BalancingError][chemsynthcalc.chem_errors.BalancingError] if can't balance reaction by any method.\n        \"\"\"\n        try:\n            return (self.inv(), \"inverse\")\n        except Exception:\n            pass\n        try:\n            return (self.gpinv(), \"general pseudoinverse\")\n        except Exception:\n            pass\n        try:\n            return (self.gpinv(), \"partial pseudoinverse\")\n        except Exception:\n            raise BalancingError(\"Can't balance this reaction by any method\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer._intify_coefficients","title":"<code>_intify_coefficients(coefficients, limit)</code>","text":"<p>Reduce the coefficients to integers by finding the greatest common divider.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>list</code> <p>List of coefficients to intify</p> required <code>limit</code> <code>int</code> <p>Upper limit (max int coef)</p> required <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of intified coefficients</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def _intify_coefficients(\n    self, coefficients: list[float], limit: int\n) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    Reduce the coefficients to integers by finding the greatest common divider.\n\n    Parameters:\n        coefficients (list): List of coefficients to intify\n        limit (int): Upper limit (max int coef)\n\n    Returns:\n        A list of intified coefficients\n    \"\"\"\n    initial_coefficients = coefficients\n    frac = [Fraction(x).limit_denominator() for x in coefficients]\n    vals = [\n        int(\n            fr.numerator\n            * find_lcm([fr.denominator for fr in frac])\n            / fr.denominator\n        )\n        for fr in frac\n    ]\n    coefficients = [int(val / find_gcd(vals)) for val in vals]\n    if any(x &gt; limit for x in coefficients):\n        return initial_coefficients\n    return coefficients\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.is_reaction_balanced","title":"<code>is_reaction_balanced(reactant_matrix, product_matrix, coefficients, tolerance=1e-08)</code>  <code>staticmethod</code>","text":"<p>Checks if reaction is balanced by multiplying reactant matrix and product matrix by the respective coefficient vector. Method is static to call it outside of balancer instance.</p> <p>Parameters:</p> Name Type Description Default <code>reactant_matrix</code> <code>NDArray[float64]</code> <p>Matrix of reactants property generated by ChemicalReaction class</p> required <code>product_matrix</code> <code>NDArray[float64]</code> <p>Matrix of products property generated by ChemicalReaction class</p> required <code>coefficients</code> <code>list[float] | list[int]</code> <p>Coefficients</p> required <code>tolerance</code> <code>float</code> <p>tolerance limit for the np.allclose function</p> <code>1e-08</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if balanced within tolerance</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; reaction = ChemicalReaction(\"NH4ClO4+HNO3+HCl=HClO4+NOCl+N2O+N2O3+H2O+Cl2\")\n&gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [64, 167, 137, 80, 43, 64, 30, 240, 39])\nTrue\n&gt;&gt;&gt; reaction = ChemicalReaction(\"H2+O2=H2O\")\n&gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [2,2,2])\nFalse\n</code></pre> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>@staticmethod\ndef is_reaction_balanced(\n    reactant_matrix: npt.NDArray[np.float64],\n    product_matrix: npt.NDArray[np.float64],\n    coefficients: list[float] | list[int],\n    tolerance: float = 1e-8,\n) -&gt; bool:\n    \"\"\"\n    Checks if reaction is balanced by multiplying reactant matrix and product matrix\n    by the respective coefficient vector. Method is static to call it outside of balancer\n    instance.\n\n    Parameters:\n        reactant_matrix (npt.NDArray[np.float64]): Matrix of reactants property generated by [ChemicalReaction][chemsynthcalc.chemical_reaction.ChemicalReaction] class\n        product_matrix (npt.NDArray[np.float64]): Matrix of products property generated by [ChemicalReaction][chemsynthcalc.chemical_reaction.ChemicalReaction] class\n        coefficients (list[float] | list[int]): Coefficients\n        tolerance (float): tolerance limit for the *np.allclose* function\n\n    Returns:\n        True if balanced within tolerance\n\n    Examples:\n        &gt;&gt;&gt; reaction = ChemicalReaction(\"NH4ClO4+HNO3+HCl=HClO4+NOCl+N2O+N2O3+H2O+Cl2\")\n        &gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [64, 167, 137, 80, 43, 64, 30, 240, 39])\n        True\n        &gt;&gt;&gt; reaction = ChemicalReaction(\"H2+O2=H2O\")\n        &gt;&gt;&gt; Balancer.is_reaction_balanced(reaction.reactant_matrix, reaction.product_matrix, [2,2,2])\n        False\n    \"\"\"\n    try:\n        reactants = np.multiply(\n            reactant_matrix.T,\n            np.array(coefficients)[: reactant_matrix.shape[1], None],\n        )\n        products = np.multiply(\n            product_matrix.T,\n            np.array(coefficients)[reactant_matrix.shape[1] :, None],\n        )\n        return np.allclose(\n            reactants.sum(axis=0), products.sum(axis=0), rtol=tolerance\n        )\n\n    except Exception:\n        return False\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer._calculate_by_method","title":"<code>_calculate_by_method(method)</code>","text":"<p>Compute the coefficients list by a specific method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>One of 4 currently implemented methods (inv, gpinv, ppinv, comb)</p> required <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> Raise <p>ValueError if method is not found.  BalancingError if can't balance reaction by specified method.</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def _calculate_by_method(self, method: str) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    Compute the coefficients list by a specific method.\n\n    Parameters:\n        method (str): One of 4 currently implemented methods (inv, gpinv, ppinv, comb)\n\n    Returns:\n        A list of coefficients\n\n    Raise:\n        ValueError if method is not found. &lt;br /&gt;\n        [BalancingError][chemsynthcalc.chem_errors.BalancingError] if can't balance reaction by specified method.\n    \"\"\"\n    match method:\n\n        case \"inv\":\n            coefficients: list[float] = np.round(\n                self._inv_algorithm(), decimals=self.round_precision\n            ).tolist()  # type: ignore\n\n        case \"gpinv\":\n            coefficients: list[float] = np.round(\n                self._gpinv_algorithm(), decimals=self.round_precision + 2\n            ).tolist()  # type: ignore\n\n        case \"ppinv\":\n            coefficients: list[float] = np.round(\n                self._ppinv_algorithm(), decimals=self.round_precision + 2\n            ).tolist()  # type: ignore\n\n        case \"comb\":\n            res: npt.NDArray[np.int32] | None = self._comb_algorithm()\n            if res is not None:\n                return res.tolist()  # type: ignore\n            else:\n                raise BalancingError(f\"Can't balance reaction by {method} method\")\n\n        case _:\n            raise ValueError(f\"No method {method}\")\n\n    if (\n        Balancer.is_reaction_balanced(\n            self.reactant_matrix, self.product_matrix, coefficients\n        )\n        and all(x &gt; 0 for x in coefficients)\n        and len(coefficients) == self.reaction_matrix.shape[1]\n    ):\n        if self.intify:\n            intified = self._intify_coefficients(coefficients, self.coef_limit)\n            if all(x &lt; self.coef_limit for x in intified):\n                return intified\n            else:\n                return coefficients\n        else:\n            return coefficients\n    else:\n        raise BalancingError(f\"Can't balance reaction by {method} method\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.inv","title":"<code>inv()</code>","text":"<p>A high-level function call to compute coefficients by Thorne method.</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def inv(self) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    A high-level function call to compute coefficients by Thorne method.\n\n    Returns:\n        A list of coefficients\n    \"\"\"\n    return self._calculate_by_method(\"inv\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.gpinv","title":"<code>gpinv()</code>","text":"<p>A high-level function call to compute coefficients by Risteski general pseudoinverse method.</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def gpinv(self) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    A high-level function call to compute coefficients by\n    Risteski general pseudoinverse method.\n\n    Returns:\n        A list of coefficients\n    \"\"\"\n    return self._calculate_by_method(\"gpinv\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.ppinv","title":"<code>ppinv()</code>","text":"<p>A high-level function call to compute coefficients by Risteski partial pseudoinverse method.</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def ppinv(self) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    A high-level function call to compute coefficients by\n    Risteski partial pseudoinverse method.\n\n    Returns:\n        A list of coefficients\n    \"\"\"\n    return self._calculate_by_method(\"ppinv\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.comb","title":"<code>comb()</code>","text":"<p>A high-level function call to compute coefficients by combinatorial method.</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def comb(self) -&gt; list[float | int] | list[int]:\n    \"\"\"\n    A high-level function call to compute coefficients by\n    combinatorial method.\n\n    Returns:\n        A list of coefficients\n    \"\"\"\n    return self._calculate_by_method(\"comb\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancer.Balancer.auto","title":"<code>auto()</code>","text":"<p>A high-level function call to automatically compute coefficients by sequentially calling inv, gpinv, ppinv methods.</p> <p>Returns:</p> Type Description <code>tuple[list[float | int] | list[int], str]</code> <p>A list of coefficients</p> Raise <p>BalancingError if can't balance reaction by any method.</p> Source code in <code>src/chemsynthcalc/balancer.py</code> <pre><code>def auto(self) -&gt; tuple[list[float | int] | list[int], str]:\n    \"\"\"\n    A high-level function call to automatically compute coefficients\n    by sequentially calling inv, gpinv, ppinv methods.\n\n    Returns:\n        A list of coefficients\n\n    Raise:\n        [BalancingError][chemsynthcalc.chem_errors.BalancingError] if can't balance reaction by any method.\n    \"\"\"\n    try:\n        return (self.inv(), \"inverse\")\n    except Exception:\n        pass\n    try:\n        return (self.gpinv(), \"general pseudoinverse\")\n    except Exception:\n        pass\n    try:\n        return (self.gpinv(), \"partial pseudoinverse\")\n    except Exception:\n        raise BalancingError(\"Can't balance this reaction by any method\")\n</code></pre>"},{"location":"API/#chemsynthcalc.balancing_algos","title":"<code>balancing_algos</code>","text":""},{"location":"API/#chemsynthcalc.balancing_algos.BalancingAlgorithms","title":"<code>BalancingAlgorithms</code>","text":"<p>A collection of functions for balancing chemical reactions</p> <p>Currently implemented: Thorne algorithm (see _inv_algorithm method for details), Risteski general pseudo-inverse algorithm (see _gpinv_algorithm method for details), Risteski partial pseudo-inverse algorithm (see _ppinv_algorithm method for details), and naive combinational search algorithm (see _comb_algorithm method for details).</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray[float64]</code> <p>Reaction matrix</p> required <code>separator_pos</code> <code>int</code> <p>Position of the reaction separator (usually the separator is \"=\")</p> required <p>Attributes:</p> Name Type Description <code>reactant_matrix</code> <code>NDArray[float64]</code> <p>A matrix of the left part of the equation</p> <code>product_matrix</code> <code>NDArray[float64]</code> <p>A matrix of the right part of the equation</p> Note <p>Why use scipy.linalg.pinv, when numpy.linalg.pinv is doing the same thing and does not require the whole SciPy import?</p> <p>There are some peculiar reaction cases where (especially for _ppinv_algorithm method) the results for numpy.linalg.pinv differs from system to system (np version, OS, python version etc.). My understanding is that the cause of this behaviour lies in small differences for pinv algorithm in numpy C-libraries and BLAS-libraries, hence the difference. To avoid this, a more consistent method scipy.linalg.pinv was used.</p> Source code in <code>src/chemsynthcalc/balancing_algos.py</code> <pre><code>class BalancingAlgorithms:\n    \"\"\"\n    A collection of functions for balancing chemical reactions\n\n    Currently implemented: Thorne algorithm (see\n    [_inv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._inv_algorithm] method for details),\n    Risteski general pseudo-inverse algorithm (see\n    [_gpinv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._gpinv_algorithm] method for details),\n    Risteski partial pseudo-inverse algorithm (see\n    [_ppinv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._ppinv_algorithm] method for details),\n    and naive combinational search algorithm (see\n    [_comb_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._comb_algorithm] method for details).\n\n    Parameters:\n        matrix (npt.NDArray[np.float64]): Reaction matrix\n        separator_pos (int): Position of the reaction separator (usually the separator is \"=\")\n\n    Attributes:\n        reactant_matrix (npt.NDArray[np.float64]): A matrix of the left part of the equation\n        product_matrix (npt.NDArray[np.float64]): A matrix of the right part of the equation\n\n    Note:\n        Why use\n        [scipy.linalg.pinv](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pinv.html),\n        when\n        [numpy.linalg.pinv](https://numpy.org/doc/stable/reference/generated/numpy.linalg.pinv.html)\n        is doing the same thing and does not require the whole SciPy import?\n\n        There are some peculiar reaction cases where\n        (especially for [_ppinv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._ppinv_algorithm] method)\n        the results for [numpy.linalg.pinv](https://numpy.org/doc/stable/reference/generated/numpy.linalg.pinv.html)\n        differs from system to system (np version, OS, python version etc.). My understanding is that the cause of\n        this behaviour lies in small differences for pinv algorithm in numpy C-libraries and BLAS-libraries,\n        hence the difference.\n        To avoid this, a more consistent method\n        [scipy.linalg.pinv](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.pinv.html) was used.\n    \"\"\"\n\n    def __init__(self, matrix: npt.NDArray[np.float64], separator_pos: int) -&gt; None:\n        self.separator_pos = separator_pos\n        self.reaction_matrix: npt.NDArray[np.float64] = matrix\n        self.reactant_matrix: npt.NDArray[np.float64] = self.reaction_matrix[\n            :, : self.separator_pos\n        ]\n        self.product_matrix: npt.NDArray[np.float64] = self.reaction_matrix[\n            :, self.separator_pos :\n        ]\n\n    def _inv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Matrix inverse algorithm for reaction balancing.\n\n        A reaction matrix inverse algorithm proposed by [Thorne](https://arxiv.org/abs/1110.4321).\n        The calculation is based on the nullity, or dimensionality, of the matrix.\n\n        The algorithm can be described in steps:\n\n        1) If the number of rows is greater than the number of columns, \\\n        add zero columns until the matrix becomes square \\\n        (Note: this is a modification of the original \\\n        Thorne method described in the article).\n\n        2) If reaction matrix is square (which means that the number \\\n        of atoms involved is equal to the number of compounds) than \\\n        we turn matrix in its row-echelon form by singular value \\\n        decomposition.\n\n        3) Calculation of the nullity of the matrix, which is \\\n        basically number of compounds minus rank of the matrix.\n\n        4) Create a  matrix augumented by nullity number of rows \\\n        of flipped identity matrix. If any rows are zeros, \\\n        replace them with identity matrix rows.\n\n        5) Inverse the augumented matrix.\n\n        6) Exctract and transpose rightmost column.\n\n        7) Normalize this value with the absolute min value of the vector.\n\n        8) Round up float operations errors.\n\n        The absolute values of this vector are coefficients of the\n        reaction.\n\n        Note:\n            While this method works great for reactions with 0 and 1\n            nullity, it generally cannot work with nullities 2 and higher.\n            Thorne claims that for higher nullities, a nullity number\n            of vectors should be extracted, and each of them contains\n            a set of correct coefficients. However, if number of rows in\n            the flipped augmentation identity matrix is 2 or more, one can\n            easily see that each vector will contain nullity-1 zeroes,\n            therefore they cannot be a correct vector of coefficients.\n\n        Returns:\n            A 1D NumPy array of calculated coefficients\n        \"\"\"\n        reaction_matrix = self.reaction_matrix\n\n        if reaction_matrix.shape[0] &gt; reaction_matrix.shape[1]:\n            zeros_added = reaction_matrix.shape[0] - reaction_matrix.shape[1]\n            zero_columns = np.zeros(\n                (\n                    reaction_matrix.shape[0],\n                    zeros_added,\n                )\n            )\n            reaction_matrix = np.hstack((reaction_matrix, zero_columns))\n        else:\n            zeros_added = 0\n\n        if reaction_matrix.shape[0] == reaction_matrix.shape[1]:\n            _, _, reaction_matrix = np.linalg.svd(reaction_matrix)\n\n        number_of_cols = reaction_matrix.shape[1]\n        rank = np.linalg.matrix_rank(reaction_matrix, tol=1e-100)\n        nullity = number_of_cols - rank\n        augument = np.flip(np.identity(reaction_matrix.shape[1])[:nullity], axis=1)\n        augumented_matrix = np.vstack((reaction_matrix, augument))\n        if np.where(~augumented_matrix.any(axis=1))[0].size &gt; 0:\n            augumented_matrix = augumented_matrix[\n                ~np.all(augumented_matrix == 0, axis=1)\n            ]\n        inversed_matrix = np.linalg.inv(augumented_matrix)\n        vector = inversed_matrix[:, -zeros_added - 1].T\n        vector = np.absolute(np.squeeze(np.asarray(vector)))\n        vector = vector[vector != 0]\n        coefs = np.divide(vector, vector.min())\n        return coefs\n\n    def _gpinv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Matrix gerenal pseudoinverse algorithm for reaction balancing.\n\n        A reaction matrix pseudoinverse algorithm\n        proposed by [Risteski](http://koreascience.or.kr/article/JAKO201314358624990.page).\n        There are other articles and methods of chemical\n        equation balancing by this author, however, this particular\n        algorithm seems to be most convenient for matrix calculations.\n        The algorithm can be described in steps:\n\n        1) Stack reactant matrix and negative product matrix.\n\n        2) Calculate MP pseudoinverse of this matrix.\n\n        3) Calculate coefficients by formula:\n        x = (I \u2013 A+A)a, where x is the coefficients vector,\n        I - identity matrix, A+ - MP inverse, A - matrix,\n        a - arbitrary vector (in this case, vector of ones).\n\n        Note:\n            This method is more general than Thorne's method, although it has some\n            peculiarities of its own. First of all, the output of this method is float array,\n            so, to generate an int coefs list, it needs to be converted, which is\n            not always leads to a good result. Secondly, MP pseudoinverse\n            is sensetive to row order in the reaction matrix. The rows should\n            be ordered by atoms apperances in the reaction string.\n\n        Returns:\n            A 1D NumPy array of calculated coefficients\n        \"\"\"\n        matrix = np.hstack((self.reactant_matrix, -self.product_matrix))\n        inverse = scipy.linalg.pinv(matrix)\n        a = np.ones((matrix.shape[1], 1))\n        i = np.identity(matrix.shape[1])\n        coefs = (i - inverse @ matrix) @ a\n        return coefs.flat[:]\n\n    def _ppinv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"\n        Matrix partial pseudoinverse algorithm for reaction balancing.\n\n        A reaction matrix pseudoinverse algorithm also\n        proposed by [Risteski](https://www.koreascience.or.kr/article/JAKO200802727293429.page).\n        The method is founded on virtue of the solution of a\n        Diophantine matrix equation by using of a Moore-Penrose\n        pseudoinverse matrix.\n\n        The algorithm can be described in steps:\n\n        1) Take the Moore-Penrose pseudoinverse of the reactant matrix.\n\n        2) Create a G matrix in the form of (I-AA^-)B, where\n        I is the identity matrix, A is the reactant matrix, A^- is\n        the MP pseudoinverse of A and B is the product matrix.\n\n        3) Then, the vector y (coefficients of products) is equal to\n        (I-G^-G)u.\n\n        4) Vector x (coefficients of reactants) is equal to\n        A^-By + (I-A^-A)v, where u and v are columns of ones.\n\n        Note:\n            While this algorithm and\n            [_gpinv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._gpinv_algorithm]\n            are very similar, there are some differences in output results.\n            This method exists mostly for legacy purposes, like balancing\n            some reactions according to [Risteski](https://www.koreascience.or.kr/article/JAKO200802727293429.page).\n\n        Returns:\n            A 1D NumPy array of calculated coefficients\n        \"\"\"\n        MP_inverse = scipy.linalg.pinv(self.reactant_matrix)\n        g_matrix = (\n            np.identity(self.reaction_matrix.shape[0])\n            - self.reactant_matrix @ MP_inverse\n        )\n        g_matrix = g_matrix @ self.product_matrix\n        y_multiply = scipy.linalg.pinv(g_matrix) @ g_matrix\n        y_vector = (np.identity(y_multiply.shape[1]) - y_multiply).dot(\n            np.ones(y_multiply.shape[1])\n        )\n        x_multiply = MP_inverse @ self.reactant_matrix\n        x_multiply = (\n            np.identity(x_multiply.shape[1]) - x_multiply\n        ) + MP_inverse @ self.product_matrix @ y_vector.T\n        x_vector = x_multiply[0].T\n        coefs = np.squeeze(np.asarray(np.hstack((x_vector, y_vector))))\n        return coefs\n\n    def _comb_algorithm(\n        self, max_number_of_iterations: float = 1e8\n    ) -&gt; npt.NDArray[np.int32] | None:\n        \"\"\"\n        Matrix combinatorial algorithm for reaction balancing.\n\n        Finds a solution solution of a Diophantine matrix equation\n        by simply enumerating of all possible solutions of number_of_iterations\n        coefficients. The solution space is created by Cartesian product\n        (in this case, *np.meshgrid* function), and therefore it is very\n        limited by memory. There must a better, clever and fast solution\n        to this!\n\n        Important:\n            Only for integer coefficients less than 128. Only for reactions\n            with total compound count &lt;=10.\n            A GPU-accelerated version of this method can be done by importing\n            CuPy and replacing np. with cp.\n\n        Note:\n            All possible variations of coefficients vectors are\n            combinations = max_coefficients**number_of_compounds,\n            therefore this method is most effective for reaction with\n            small numbers of compounds.\n\n        Returns:\n            A 1D NumPy array of calculated coefficients of None if can't compute\n        \"\"\"\n        byte = 127\n        number_of_compounds = self.reaction_matrix.shape[1]\n        if number_of_compounds &gt; 10:\n            raise ValueError(\"Sorry, this method is only for n of compound &lt;=10\")\n\n        number_of_iterations = int(\n            max_number_of_iterations ** (1 / number_of_compounds)\n        )\n\n        if number_of_iterations &gt; byte:\n            number_of_iterations = byte\n\n        trans_reaction_matrix = (self.reaction_matrix).T\n        lenght = self.reactant_matrix.shape[1]\n        old_reactants = trans_reaction_matrix[:lenght].astype(\"ushort\")\n        old_products = trans_reaction_matrix[lenght:].astype(\"ushort\")\n        for i in range(2, number_of_iterations + 2):\n            cart_array = (np.arange(1, i, dtype=\"ubyte\"),) * number_of_compounds\n            permuted = np.array(np.meshgrid(*cart_array), dtype=\"ubyte\").T.reshape(\n                -1, number_of_compounds\n            )\n            filter = np.asarray([i - 1], dtype=\"ubyte\")\n            permuted = permuted[np.any(permuted == filter, axis=1)]\n            # print(\"calculating max coef %s of %s\" % (i-1, number_of_iterations), end='\\r', flush=False)\n            reactants_vectors = permuted[:, :lenght]\n            products_vectors = permuted[:, lenght:]\n            del permuted\n            reactants = (old_reactants[None, :, :] * reactants_vectors[:, :, None]).sum(\n                axis=1\n            )\n            products = (old_products[None, :, :] * products_vectors[:, :, None]).sum(\n                axis=1\n            )\n            diff = np.subtract(reactants, products)\n            del reactants\n            del products\n            where = np.where(~diff.any(axis=1))[0]\n            if np.any(where):\n                if where.shape[0] == 1:\n                    idx = where\n                else:\n                    idx = where[0]\n                # print(\"\")\n                return np.array(\n                    np.concatenate(\n                        (\n                            reactants_vectors[idx].flatten(),\n                            products_vectors[idx].flatten(),\n                        )\n                    )\n                )\n            gc.collect()\n        # print(\"\")\n        return None\n</code></pre>"},{"location":"API/#chemsynthcalc.balancing_algos.BalancingAlgorithms._inv_algorithm","title":"<code>_inv_algorithm()</code>","text":"<p>Matrix inverse algorithm for reaction balancing.</p> <p>A reaction matrix inverse algorithm proposed by Thorne. The calculation is based on the nullity, or dimensionality, of the matrix.</p> <p>The algorithm can be described in steps:</p> <p>1) If the number of rows is greater than the number of columns,         add zero columns until the matrix becomes square         (Note: this is a modification of the original         Thorne method described in the article).</p> <p>2) If reaction matrix is square (which means that the number         of atoms involved is equal to the number of compounds) than         we turn matrix in its row-echelon form by singular value         decomposition.</p> <p>3) Calculation of the nullity of the matrix, which is         basically number of compounds minus rank of the matrix.</p> <p>4) Create a  matrix augumented by nullity number of rows         of flipped identity matrix. If any rows are zeros,         replace them with identity matrix rows.</p> <p>5) Inverse the augumented matrix.</p> <p>6) Exctract and transpose rightmost column.</p> <p>7) Normalize this value with the absolute min value of the vector.</p> <p>8) Round up float operations errors.</p> <p>The absolute values of this vector are coefficients of the reaction.</p> Note <p>While this method works great for reactions with 0 and 1 nullity, it generally cannot work with nullities 2 and higher. Thorne claims that for higher nullities, a nullity number of vectors should be extracted, and each of them contains a set of correct coefficients. However, if number of rows in the flipped augmentation identity matrix is 2 or more, one can easily see that each vector will contain nullity-1 zeroes, therefore they cannot be a correct vector of coefficients.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A 1D NumPy array of calculated coefficients</p> Source code in <code>src/chemsynthcalc/balancing_algos.py</code> <pre><code>def _inv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Matrix inverse algorithm for reaction balancing.\n\n    A reaction matrix inverse algorithm proposed by [Thorne](https://arxiv.org/abs/1110.4321).\n    The calculation is based on the nullity, or dimensionality, of the matrix.\n\n    The algorithm can be described in steps:\n\n    1) If the number of rows is greater than the number of columns, \\\n    add zero columns until the matrix becomes square \\\n    (Note: this is a modification of the original \\\n    Thorne method described in the article).\n\n    2) If reaction matrix is square (which means that the number \\\n    of atoms involved is equal to the number of compounds) than \\\n    we turn matrix in its row-echelon form by singular value \\\n    decomposition.\n\n    3) Calculation of the nullity of the matrix, which is \\\n    basically number of compounds minus rank of the matrix.\n\n    4) Create a  matrix augumented by nullity number of rows \\\n    of flipped identity matrix. If any rows are zeros, \\\n    replace them with identity matrix rows.\n\n    5) Inverse the augumented matrix.\n\n    6) Exctract and transpose rightmost column.\n\n    7) Normalize this value with the absolute min value of the vector.\n\n    8) Round up float operations errors.\n\n    The absolute values of this vector are coefficients of the\n    reaction.\n\n    Note:\n        While this method works great for reactions with 0 and 1\n        nullity, it generally cannot work with nullities 2 and higher.\n        Thorne claims that for higher nullities, a nullity number\n        of vectors should be extracted, and each of them contains\n        a set of correct coefficients. However, if number of rows in\n        the flipped augmentation identity matrix is 2 or more, one can\n        easily see that each vector will contain nullity-1 zeroes,\n        therefore they cannot be a correct vector of coefficients.\n\n    Returns:\n        A 1D NumPy array of calculated coefficients\n    \"\"\"\n    reaction_matrix = self.reaction_matrix\n\n    if reaction_matrix.shape[0] &gt; reaction_matrix.shape[1]:\n        zeros_added = reaction_matrix.shape[0] - reaction_matrix.shape[1]\n        zero_columns = np.zeros(\n            (\n                reaction_matrix.shape[0],\n                zeros_added,\n            )\n        )\n        reaction_matrix = np.hstack((reaction_matrix, zero_columns))\n    else:\n        zeros_added = 0\n\n    if reaction_matrix.shape[0] == reaction_matrix.shape[1]:\n        _, _, reaction_matrix = np.linalg.svd(reaction_matrix)\n\n    number_of_cols = reaction_matrix.shape[1]\n    rank = np.linalg.matrix_rank(reaction_matrix, tol=1e-100)\n    nullity = number_of_cols - rank\n    augument = np.flip(np.identity(reaction_matrix.shape[1])[:nullity], axis=1)\n    augumented_matrix = np.vstack((reaction_matrix, augument))\n    if np.where(~augumented_matrix.any(axis=1))[0].size &gt; 0:\n        augumented_matrix = augumented_matrix[\n            ~np.all(augumented_matrix == 0, axis=1)\n        ]\n    inversed_matrix = np.linalg.inv(augumented_matrix)\n    vector = inversed_matrix[:, -zeros_added - 1].T\n    vector = np.absolute(np.squeeze(np.asarray(vector)))\n    vector = vector[vector != 0]\n    coefs = np.divide(vector, vector.min())\n    return coefs\n</code></pre>"},{"location":"API/#chemsynthcalc.balancing_algos.BalancingAlgorithms._gpinv_algorithm","title":"<code>_gpinv_algorithm()</code>","text":"<p>Matrix gerenal pseudoinverse algorithm for reaction balancing.</p> <p>A reaction matrix pseudoinverse algorithm proposed by Risteski. There are other articles and methods of chemical equation balancing by this author, however, this particular algorithm seems to be most convenient for matrix calculations. The algorithm can be described in steps:</p> <p>1) Stack reactant matrix and negative product matrix.</p> <p>2) Calculate MP pseudoinverse of this matrix.</p> <p>3) Calculate coefficients by formula: x = (I \u2013 A+A)a, where x is the coefficients vector, I - identity matrix, A+ - MP inverse, A - matrix, a - arbitrary vector (in this case, vector of ones).</p> Note <p>This method is more general than Thorne's method, although it has some peculiarities of its own. First of all, the output of this method is float array, so, to generate an int coefs list, it needs to be converted, which is not always leads to a good result. Secondly, MP pseudoinverse is sensetive to row order in the reaction matrix. The rows should be ordered by atoms apperances in the reaction string.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A 1D NumPy array of calculated coefficients</p> Source code in <code>src/chemsynthcalc/balancing_algos.py</code> <pre><code>def _gpinv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Matrix gerenal pseudoinverse algorithm for reaction balancing.\n\n    A reaction matrix pseudoinverse algorithm\n    proposed by [Risteski](http://koreascience.or.kr/article/JAKO201314358624990.page).\n    There are other articles and methods of chemical\n    equation balancing by this author, however, this particular\n    algorithm seems to be most convenient for matrix calculations.\n    The algorithm can be described in steps:\n\n    1) Stack reactant matrix and negative product matrix.\n\n    2) Calculate MP pseudoinverse of this matrix.\n\n    3) Calculate coefficients by formula:\n    x = (I \u2013 A+A)a, where x is the coefficients vector,\n    I - identity matrix, A+ - MP inverse, A - matrix,\n    a - arbitrary vector (in this case, vector of ones).\n\n    Note:\n        This method is more general than Thorne's method, although it has some\n        peculiarities of its own. First of all, the output of this method is float array,\n        so, to generate an int coefs list, it needs to be converted, which is\n        not always leads to a good result. Secondly, MP pseudoinverse\n        is sensetive to row order in the reaction matrix. The rows should\n        be ordered by atoms apperances in the reaction string.\n\n    Returns:\n        A 1D NumPy array of calculated coefficients\n    \"\"\"\n    matrix = np.hstack((self.reactant_matrix, -self.product_matrix))\n    inverse = scipy.linalg.pinv(matrix)\n    a = np.ones((matrix.shape[1], 1))\n    i = np.identity(matrix.shape[1])\n    coefs = (i - inverse @ matrix) @ a\n    return coefs.flat[:]\n</code></pre>"},{"location":"API/#chemsynthcalc.balancing_algos.BalancingAlgorithms._ppinv_algorithm","title":"<code>_ppinv_algorithm()</code>","text":"<p>Matrix partial pseudoinverse algorithm for reaction balancing.</p> <p>A reaction matrix pseudoinverse algorithm also proposed by Risteski. The method is founded on virtue of the solution of a Diophantine matrix equation by using of a Moore-Penrose pseudoinverse matrix.</p> <p>The algorithm can be described in steps:</p> <p>1) Take the Moore-Penrose pseudoinverse of the reactant matrix.</p> <p>2) Create a G matrix in the form of (I-AA^-)B, where I is the identity matrix, A is the reactant matrix, A^- is the MP pseudoinverse of A and B is the product matrix.</p> <p>3) Then, the vector y (coefficients of products) is equal to (I-G^-G)u.</p> <p>4) Vector x (coefficients of reactants) is equal to A^-By + (I-A^-A)v, where u and v are columns of ones.</p> Note <p>While this algorithm and _gpinv_algorithm are very similar, there are some differences in output results. This method exists mostly for legacy purposes, like balancing some reactions according to Risteski.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A 1D NumPy array of calculated coefficients</p> Source code in <code>src/chemsynthcalc/balancing_algos.py</code> <pre><code>def _ppinv_algorithm(self) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Matrix partial pseudoinverse algorithm for reaction balancing.\n\n    A reaction matrix pseudoinverse algorithm also\n    proposed by [Risteski](https://www.koreascience.or.kr/article/JAKO200802727293429.page).\n    The method is founded on virtue of the solution of a\n    Diophantine matrix equation by using of a Moore-Penrose\n    pseudoinverse matrix.\n\n    The algorithm can be described in steps:\n\n    1) Take the Moore-Penrose pseudoinverse of the reactant matrix.\n\n    2) Create a G matrix in the form of (I-AA^-)B, where\n    I is the identity matrix, A is the reactant matrix, A^- is\n    the MP pseudoinverse of A and B is the product matrix.\n\n    3) Then, the vector y (coefficients of products) is equal to\n    (I-G^-G)u.\n\n    4) Vector x (coefficients of reactants) is equal to\n    A^-By + (I-A^-A)v, where u and v are columns of ones.\n\n    Note:\n        While this algorithm and\n        [_gpinv_algorithm][chemsynthcalc.balancing_algos.BalancingAlgorithms._gpinv_algorithm]\n        are very similar, there are some differences in output results.\n        This method exists mostly for legacy purposes, like balancing\n        some reactions according to [Risteski](https://www.koreascience.or.kr/article/JAKO200802727293429.page).\n\n    Returns:\n        A 1D NumPy array of calculated coefficients\n    \"\"\"\n    MP_inverse = scipy.linalg.pinv(self.reactant_matrix)\n    g_matrix = (\n        np.identity(self.reaction_matrix.shape[0])\n        - self.reactant_matrix @ MP_inverse\n    )\n    g_matrix = g_matrix @ self.product_matrix\n    y_multiply = scipy.linalg.pinv(g_matrix) @ g_matrix\n    y_vector = (np.identity(y_multiply.shape[1]) - y_multiply).dot(\n        np.ones(y_multiply.shape[1])\n    )\n    x_multiply = MP_inverse @ self.reactant_matrix\n    x_multiply = (\n        np.identity(x_multiply.shape[1]) - x_multiply\n    ) + MP_inverse @ self.product_matrix @ y_vector.T\n    x_vector = x_multiply[0].T\n    coefs = np.squeeze(np.asarray(np.hstack((x_vector, y_vector))))\n    return coefs\n</code></pre>"},{"location":"API/#chemsynthcalc.balancing_algos.BalancingAlgorithms._comb_algorithm","title":"<code>_comb_algorithm(max_number_of_iterations=100000000.0)</code>","text":"<p>Matrix combinatorial algorithm for reaction balancing.</p> <p>Finds a solution solution of a Diophantine matrix equation by simply enumerating of all possible solutions of number_of_iterations coefficients. The solution space is created by Cartesian product (in this case, np.meshgrid function), and therefore it is very limited by memory. There must a better, clever and fast solution to this!</p> Important <p>Only for integer coefficients less than 128. Only for reactions with total compound count &lt;=10. A GPU-accelerated version of this method can be done by importing CuPy and replacing np. with cp.</p> Note <p>All possible variations of coefficients vectors are combinations = max_coefficients**number_of_compounds, therefore this method is most effective for reaction with small numbers of compounds.</p> <p>Returns:</p> Type Description <code>NDArray[int32] | None</code> <p>A 1D NumPy array of calculated coefficients of None if can't compute</p> Source code in <code>src/chemsynthcalc/balancing_algos.py</code> <pre><code>def _comb_algorithm(\n    self, max_number_of_iterations: float = 1e8\n) -&gt; npt.NDArray[np.int32] | None:\n    \"\"\"\n    Matrix combinatorial algorithm for reaction balancing.\n\n    Finds a solution solution of a Diophantine matrix equation\n    by simply enumerating of all possible solutions of number_of_iterations\n    coefficients. The solution space is created by Cartesian product\n    (in this case, *np.meshgrid* function), and therefore it is very\n    limited by memory. There must a better, clever and fast solution\n    to this!\n\n    Important:\n        Only for integer coefficients less than 128. Only for reactions\n        with total compound count &lt;=10.\n        A GPU-accelerated version of this method can be done by importing\n        CuPy and replacing np. with cp.\n\n    Note:\n        All possible variations of coefficients vectors are\n        combinations = max_coefficients**number_of_compounds,\n        therefore this method is most effective for reaction with\n        small numbers of compounds.\n\n    Returns:\n        A 1D NumPy array of calculated coefficients of None if can't compute\n    \"\"\"\n    byte = 127\n    number_of_compounds = self.reaction_matrix.shape[1]\n    if number_of_compounds &gt; 10:\n        raise ValueError(\"Sorry, this method is only for n of compound &lt;=10\")\n\n    number_of_iterations = int(\n        max_number_of_iterations ** (1 / number_of_compounds)\n    )\n\n    if number_of_iterations &gt; byte:\n        number_of_iterations = byte\n\n    trans_reaction_matrix = (self.reaction_matrix).T\n    lenght = self.reactant_matrix.shape[1]\n    old_reactants = trans_reaction_matrix[:lenght].astype(\"ushort\")\n    old_products = trans_reaction_matrix[lenght:].astype(\"ushort\")\n    for i in range(2, number_of_iterations + 2):\n        cart_array = (np.arange(1, i, dtype=\"ubyte\"),) * number_of_compounds\n        permuted = np.array(np.meshgrid(*cart_array), dtype=\"ubyte\").T.reshape(\n            -1, number_of_compounds\n        )\n        filter = np.asarray([i - 1], dtype=\"ubyte\")\n        permuted = permuted[np.any(permuted == filter, axis=1)]\n        # print(\"calculating max coef %s of %s\" % (i-1, number_of_iterations), end='\\r', flush=False)\n        reactants_vectors = permuted[:, :lenght]\n        products_vectors = permuted[:, lenght:]\n        del permuted\n        reactants = (old_reactants[None, :, :] * reactants_vectors[:, :, None]).sum(\n            axis=1\n        )\n        products = (old_products[None, :, :] * products_vectors[:, :, None]).sum(\n            axis=1\n        )\n        diff = np.subtract(reactants, products)\n        del reactants\n        del products\n        where = np.where(~diff.any(axis=1))[0]\n        if np.any(where):\n            if where.shape[0] == 1:\n                idx = where\n            else:\n                idx = where[0]\n            # print(\"\")\n            return np.array(\n                np.concatenate(\n                    (\n                        reactants_vectors[idx].flatten(),\n                        products_vectors[idx].flatten(),\n                    )\n                )\n            )\n        gc.collect()\n    # print(\"\")\n    return None\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors","title":"<code>chem_errors</code>","text":"<p>Module that contains custom errors for use in <code>ChemSynthCalc</code></p>"},{"location":"API/#chemsynthcalc.chem_errors.EmptyFormula","title":"<code>EmptyFormula</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The formula string is empty</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class EmptyFormula(Exception):\n    \"\"\"\n    The formula string is empty\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.NoSuchAtom","title":"<code>NoSuchAtom</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Found atom(s) that are not in the periodic table.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class NoSuchAtom(Exception):\n    \"\"\"\n    Found atom(s) that are not in the periodic table.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.InvalidCharacter","title":"<code>InvalidCharacter</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Found some characters that do not belong in the chemical formula or reaction.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class InvalidCharacter(Exception):\n    \"\"\"\n    Found some characters that do not belong in the\n    chemical formula or reaction.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.MoreThanOneAdduct","title":"<code>MoreThanOneAdduct</code>","text":"<p>               Bases: <code>Exception</code></p> <p>There is more than one adduct (*).</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class MoreThanOneAdduct(Exception):\n    \"\"\"\n    There is more than one adduct (*).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.BracketsNotPaired","title":"<code>BracketsNotPaired</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Some brackets do not come in pairs.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class BracketsNotPaired(Exception):\n    \"\"\"\n    Some brackets do not come in pairs.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.EmptyReaction","title":"<code>EmptyReaction</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The reaction string is empty</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class EmptyReaction(Exception):\n    \"\"\"\n    The reaction string is empty\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.NoSuchMode","title":"<code>NoSuchMode</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid calculation mode detected.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class NoSuchMode(Exception):\n    \"\"\"\n    Invalid calculation mode detected.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.NoSuchAlgorithm","title":"<code>NoSuchAlgorithm</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Invalid calculation algorithm detected.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class NoSuchAlgorithm(Exception):\n    \"\"\"\n    Invalid calculation algorithm detected.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.NoSeparator","title":"<code>NoSeparator</code>","text":"<p>               Bases: <code>Exception</code></p> <p>No separator was found in the reaction string.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class NoSeparator(Exception):\n    \"\"\"\n    No separator was found in the reaction string.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.ReactionNotBalanced","title":"<code>ReactionNotBalanced</code>","text":"<p>               Bases: <code>Exception</code></p> <p>This reaction is not balanced.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class ReactionNotBalanced(Exception):\n    \"\"\"\n    This reaction is not balanced.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.ReactantProductDifference","title":"<code>ReactantProductDifference</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The elements in reaction are not evenly distributed in reactants and products: some of atoms are only in one part of reaction.</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class ReactantProductDifference(Exception):\n    \"\"\"\n    The elements in reaction are not evenly\n    distributed in reactants and products:\n    some of atoms are only in one part of\n    reaction.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.BadCoeffiecients","title":"<code>BadCoeffiecients</code>","text":"<p>               Bases: <code>Exception</code></p> <p>The coefficients are not not compliant (they have no physical meaning).</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class BadCoeffiecients(Exception):\n    \"\"\"\n    The coefficients are not not compliant\n    (they have no physical meaning).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_errors.BalancingError","title":"<code>BalancingError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Can't balance reaction by this method</p> Source code in <code>src/chemsynthcalc/chem_errors.py</code> <pre><code>class BalancingError(Exception):\n    \"\"\"\n    Can't balance reaction by this method\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output","title":"<code>chem_output</code>","text":""},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput","title":"<code>ChemicalOutput</code>","text":"<p>Methods of this class prepare output from ChemicalFormula and ChemicalReaction objects and output it in different ways.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>dict[str, object]</code> <p>Output dictionary</p> required <code>print_precision</code> <code>int</code> <p>How many decimal places to print out</p> required <code>obj</code> <code>str</code> <p>Type of object (\"formula\" or \"reaction\")</p> required <p>Attributes:</p> Name Type Description <code>rounded_values</code> <code>dict[str, object]</code> <p>Output dictionary rounded to print_precision</p> <code>original_stdout</code> <code>TextIO | Any</code> <p>Default stdout</p> Raise <p>ValueError if print_precision &lt;= 0  ValueError if obj is not \"ChemicalFormula\" or \"ChemicalReaction\"</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>class ChemicalOutput:\n    \"\"\"\n    Methods of this class prepare output from\n    [ChemicalFormula][chemsynthcalc.chemical_formula.ChemicalFormula]\n    and\n    [ChemicalReaction][chemsynthcalc.chemical_reaction.ChemicalReaction]\n    objects and output it in different ways.\n\n    Arguments:\n        output (dict[str, object]): Output dictionary\n        print_precision (int): How many decimal places to print out\n        obj (str): Type of object (\"formula\" or \"reaction\")\n\n    Attributes:\n        rounded_values (dict[str, object]): Output dictionary rounded to print_precision\n        original_stdout (TextIO | Any): Default stdout\n\n    Raise:\n        ValueError if print_precision &lt;= 0 &lt;br / &gt;\n        ValueError if obj is not \"ChemicalFormula\" or \"ChemicalReaction\"\n    \"\"\"\n\n    def __init__(\n        self, output: dict[str, object], print_precision: int, obj: str\n    ) -&gt; None:\n        if print_precision &gt; 0:\n            self.print_precision: int = print_precision\n        else:\n            raise ValueError(\"precision &lt;= 0\")\n\n        if obj in {\"ChemicalFormula\", \"ChemicalReaction\"}:\n            self.obj = obj\n        else:\n            raise ValueError(f\"No object of a class: {obj}\")\n\n        self.output: dict[str, object] = output\n        self.rounded_values: dict[str, object] = self._round_values()\n        self.original_stdout = sys.stdout\n\n    def _round_values(self) -&gt; dict[str, object]:\n        \"\"\"\n        Round values of output dictionary to the print_precision.\n        Rounding is different depending on the type of the value.\n\n        Returns:\n            Rounded dictionary\n        \"\"\"\n        rounded_dict: dict[str, object] = {}\n        for name, value in self.output.items():\n            if isinstance(value, float):\n                rounded_value = round(value, self.print_precision)\n            elif isinstance(value, dict):\n                rounded_value = round_dict_content(value, self.print_precision)  # type: ignore\n            elif name == \"masses\":\n                rounded_value = [round(v, self.print_precision) for v in value]  # type: ignore\n            elif name == \"reaction matrix\":\n                rounded_value = np.array2string(value)  # type: ignore\n            else:\n                rounded_value = value\n\n            rounded_dict.update({name: rounded_value})  # type: ignore\n\n        return rounded_dict\n\n    def _generate_filename(self, file_type: str) -&gt; str:\n        \"\"\"\n        Generates a filename for an output file in the form of:\n        \"CSC_object type_formula or target_nanosec since the Epoch.txt or json\"\n\n        Returns:\n            String of a filename\n        \"\"\"\n        if self.obj == \"ChemicalFormula\":\n            filename: str = (\n                f\"CSC_{self.obj}_{self.output.get(\"formula\")}_{time.time_ns()}.{file_type}\"\n            )\n        else:\n            filename: str = (\n                f\"CSC_{self.obj}_{self.output.get(\"target\")}_{time.time_ns()}.{file_type}\"\n            )\n\n        return filename\n\n    def _print_additional_reaction_results(self) -&gt; None:\n        \"\"\"\n        Print output masses in a user-friendly human-readable format.\n        \"\"\"\n        for i, formula in enumerate(self.output[\"formulas\"]):  # type: ignore\n            print(\n                \"%s: M = %s g/mol, m = %s g\"\n                % (\n                    formula,\n                    \"%.{0}f\".format(self.print_precision)\n                    % round(self.output[\"molar masses\"][i], self.print_precision),  # type: ignore\n                    \"%.{0}f\".format(self.print_precision)\n                    % round(self.output[\"masses\"][i], self.print_precision),  # type: ignore\n                )\n            )\n\n    def _print_stream(self) -&gt; None:\n        \"\"\"\n        Final print stream that can go to different outputs.\n        \"\"\"\n        for name, rounded_value in self.rounded_values.items():\n            if name == \"reaction matrix\":\n                print(name + \":\\n\", rounded_value)\n            else:\n                print(name + \":\", rounded_value)\n        if self.obj == \"ChemicalReaction\":\n            self._print_additional_reaction_results()\n\n    def print_results(self) -&gt; None:\n        \"\"\"\n        Print a final result of calculations in stdout.\n        \"\"\"\n        sys.stdout = self.original_stdout\n        self._print_stream()\n\n    def write_to_txt(self, filename: str) -&gt; None:\n        \"\"\"\n        Export the final result of the calculations in a txt file.\n\n        Arguments:\n            filename (str): filename string (should end with .txt)\n        \"\"\"\n        if filename == \"default\":\n            filename = self._generate_filename(\"txt\")\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            sys.stdout = file\n            self._print_stream()\n\n        sys.stdout = self.original_stdout\n\n    def dump_to_json(self) -&gt; str:\n        \"\"\"\n        Serialization of output into JSON object.\n\n        Returns:\n            A JSON-type object\n        \"\"\"\n        return json.dumps(self.rounded_values, ensure_ascii=False)\n\n    def write_to_json_file(self, filename: str) -&gt; None:\n        \"\"\"\n        Export a final result of calculations in a JSON file.\n\n        Arguments:\n            filename (str): filename string (should end with .json)\n        \"\"\"\n        if filename == \"default\":\n            filename = self._generate_filename(\"json\")\n\n        with open(filename, \"w\", encoding=\"utf-8\") as file:\n            json.dump(json.loads(self.dump_to_json()), file, ensure_ascii=False)\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput._round_values","title":"<code>_round_values()</code>","text":"<p>Round values of output dictionary to the print_precision. Rounding is different depending on the type of the value.</p> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>Rounded dictionary</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def _round_values(self) -&gt; dict[str, object]:\n    \"\"\"\n    Round values of output dictionary to the print_precision.\n    Rounding is different depending on the type of the value.\n\n    Returns:\n        Rounded dictionary\n    \"\"\"\n    rounded_dict: dict[str, object] = {}\n    for name, value in self.output.items():\n        if isinstance(value, float):\n            rounded_value = round(value, self.print_precision)\n        elif isinstance(value, dict):\n            rounded_value = round_dict_content(value, self.print_precision)  # type: ignore\n        elif name == \"masses\":\n            rounded_value = [round(v, self.print_precision) for v in value]  # type: ignore\n        elif name == \"reaction matrix\":\n            rounded_value = np.array2string(value)  # type: ignore\n        else:\n            rounded_value = value\n\n        rounded_dict.update({name: rounded_value})  # type: ignore\n\n    return rounded_dict\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput._generate_filename","title":"<code>_generate_filename(file_type)</code>","text":"<p>Generates a filename for an output file in the form of: \"CSC_object type_formula or target_nanosec since the Epoch.txt or json\"</p> <p>Returns:</p> Type Description <code>str</code> <p>String of a filename</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def _generate_filename(self, file_type: str) -&gt; str:\n    \"\"\"\n    Generates a filename for an output file in the form of:\n    \"CSC_object type_formula or target_nanosec since the Epoch.txt or json\"\n\n    Returns:\n        String of a filename\n    \"\"\"\n    if self.obj == \"ChemicalFormula\":\n        filename: str = (\n            f\"CSC_{self.obj}_{self.output.get(\"formula\")}_{time.time_ns()}.{file_type}\"\n        )\n    else:\n        filename: str = (\n            f\"CSC_{self.obj}_{self.output.get(\"target\")}_{time.time_ns()}.{file_type}\"\n        )\n\n    return filename\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput._print_additional_reaction_results","title":"<code>_print_additional_reaction_results()</code>","text":"<p>Print output masses in a user-friendly human-readable format.</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def _print_additional_reaction_results(self) -&gt; None:\n    \"\"\"\n    Print output masses in a user-friendly human-readable format.\n    \"\"\"\n    for i, formula in enumerate(self.output[\"formulas\"]):  # type: ignore\n        print(\n            \"%s: M = %s g/mol, m = %s g\"\n            % (\n                formula,\n                \"%.{0}f\".format(self.print_precision)\n                % round(self.output[\"molar masses\"][i], self.print_precision),  # type: ignore\n                \"%.{0}f\".format(self.print_precision)\n                % round(self.output[\"masses\"][i], self.print_precision),  # type: ignore\n            )\n        )\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput._print_stream","title":"<code>_print_stream()</code>","text":"<p>Final print stream that can go to different outputs.</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def _print_stream(self) -&gt; None:\n    \"\"\"\n    Final print stream that can go to different outputs.\n    \"\"\"\n    for name, rounded_value in self.rounded_values.items():\n        if name == \"reaction matrix\":\n            print(name + \":\\n\", rounded_value)\n        else:\n            print(name + \":\", rounded_value)\n    if self.obj == \"ChemicalReaction\":\n        self._print_additional_reaction_results()\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput.print_results","title":"<code>print_results()</code>","text":"<p>Print a final result of calculations in stdout.</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def print_results(self) -&gt; None:\n    \"\"\"\n    Print a final result of calculations in stdout.\n    \"\"\"\n    sys.stdout = self.original_stdout\n    self._print_stream()\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput.write_to_txt","title":"<code>write_to_txt(filename)</code>","text":"<p>Export the final result of the calculations in a txt file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .txt)</p> required Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def write_to_txt(self, filename: str) -&gt; None:\n    \"\"\"\n    Export the final result of the calculations in a txt file.\n\n    Arguments:\n        filename (str): filename string (should end with .txt)\n    \"\"\"\n    if filename == \"default\":\n        filename = self._generate_filename(\"txt\")\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        sys.stdout = file\n        self._print_stream()\n\n    sys.stdout = self.original_stdout\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput.dump_to_json","title":"<code>dump_to_json()</code>","text":"<p>Serialization of output into JSON object.</p> <p>Returns:</p> Type Description <code>str</code> <p>A JSON-type object</p> Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def dump_to_json(self) -&gt; str:\n    \"\"\"\n    Serialization of output into JSON object.\n\n    Returns:\n        A JSON-type object\n    \"\"\"\n    return json.dumps(self.rounded_values, ensure_ascii=False)\n</code></pre>"},{"location":"API/#chemsynthcalc.chem_output.ChemicalOutput.write_to_json_file","title":"<code>write_to_json_file(filename)</code>","text":"<p>Export a final result of calculations in a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .json)</p> required Source code in <code>src/chemsynthcalc/chem_output.py</code> <pre><code>def write_to_json_file(self, filename: str) -&gt; None:\n    \"\"\"\n    Export a final result of calculations in a JSON file.\n\n    Arguments:\n        filename (str): filename string (should end with .json)\n    \"\"\"\n    if filename == \"default\":\n        filename = self._generate_filename(\"json\")\n\n    with open(filename, \"w\", encoding=\"utf-8\") as file:\n        json.dump(json.loads(self.dump_to_json()), file, ensure_ascii=False)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula","title":"<code>chemical_formula</code>","text":""},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula","title":"<code>ChemicalFormula</code>","text":"<p>A class for operations on a single chemical formula.</p> <p>It constructs with a formula string and can calculate parsed formula, molar mass, mass percent, atomic percent, oxide percent from this string using ChemicalFormulaParser and MolarMassCalculation.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>String of chemical formula</p> <code>''</code> <code>*custom_oxides</code> <code>tuple[str, ...]</code> <p>An arbitrary number of non-default oxide formulas</p> <code>()</code> <code>precision</code> <code>int</code> <p>Value of rounding precision (8 by default)</p> <code>8</code> Raise <p>ValueError: if precision &lt;= 0</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"H2O\")\nH2O\n&gt;&gt;&gt; ChemicalFormula(\"H2O\").molar_mass\n18.015\n&gt;&gt;&gt; ChemicalFormula(\"H2O\").mass_percent\n{'H': 11.19067444, 'O': 88.80932556}\n</code></pre> Source code in <code>src/chemsynthcalc/chemical_formula.py</code> <pre><code>class ChemicalFormula:\n    \"\"\"A class for operations on a single chemical formula.\n\n    It constructs with a formula string and can calculate\n    parsed formula, molar mass, mass percent, atomic percent,\n    oxide percent from this string using\n    [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser] and\n    [MolarMassCalculation][chemsynthcalc.molar_mass.MolarMassCalculation].\n\n    Parameters:\n        formula (str): String of chemical formula\n        *custom_oxides (tuple[str, ...]): An arbitrary number of non-default oxide formulas\n        precision (int): Value of rounding precision (8 by default)\n\n    Raise:\n        ValueError: if precision &lt;= 0\n\n    Examples:\n        &gt;&gt;&gt; ChemicalFormula(\"H2O\")\n        H2O\n        &gt;&gt;&gt; ChemicalFormula(\"H2O\").molar_mass\n        18.015\n        &gt;&gt;&gt; ChemicalFormula(\"H2O\").mass_percent\n        {'H': 11.19067444, 'O': 88.80932556}\n    \"\"\"\n\n    def __init__(\n        self, formula: str = \"\", *custom_oxides: str, precision: int = 8\n    ) -&gt; None:\n        if FormulaValidator(formula).validate_formula():\n            self.initial_formula: str = formula.replace(\" \", \"\")\n\n        if precision &gt; 0:\n            self.precision: int = precision\n        else:\n            raise ValueError(\"precision &lt;= 0\")\n\n        self.custom_oxides = custom_oxides\n\n    def __str__(self) -&gt; str:\n        return self.formula\n\n    def __repr__(self) -&gt; str:\n        return f\"ChemicalFormula('{self.formula}', {self.precision})\"\n\n    @property\n    @lru_cache(maxsize=1)\n    def formula(self) -&gt; str:\n        \"\"\"\n        A string of chemical formula.\n        It is made a property to be relatively immutable.\n\n        Returns:\n            The formula string\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").formula\n            K2SO4\n        \"\"\"\n        return self.initial_formula\n\n    @property\n    @lru_cache(maxsize=1)\n    def parsed_formula(self) -&gt; dict[str, float]:\n        \"\"\"\n        Formula parsed into dictionary keeping the initial atom order.\n\n        Returns:\n            Parsed dictionary representation of formula string created \\\n            by [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser]\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").parsed_formula\n            {'K': 2.0, 'S': 1.0, 'O': 4.0}\n        \"\"\"\n        parsed: dict[str, float] = ChemicalFormulaParser(self.formula).parse_formula()\n        return round_dict_content(parsed, self.precision, plus=3)\n\n    @property\n    @lru_cache(maxsize=1)\n    def molar_mass(self) -&gt; float:\n        \"\"\"\n        Molar mass of the compound.\n\n        Returns:\n            The [molar mass](https://en.wikipedia.org/wiki/Molar_mass) \\\n            of the formula (in g/mol), calculated from \\\n            parsed the formula using [MolarMassCalculation][chemsynthcalc.molar_mass.MolarMassCalculation].\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").molar_mass\n            174.252\n        \"\"\"\n        return round(\n            MolarMassCalculation(self.parsed_formula).calculate_molar_mass(),\n            self.precision,\n        )\n\n    @property\n    @lru_cache(maxsize=1)\n    def mass_percent(self) -&gt; dict[str, float]:\n        \"\"\"\n        The percentage of mass of atoms in the formula.\n\n        Returns:\n            A mass percent or \\\n            [relative mass fraction](https://en.wikipedia.org/wiki/Mass_fraction_(chemistry)) \\\n            of atoms in parsed chemical formula. The values of \\\n            mass content are in % (with 100% sum), not fraction. \n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").mass_percent\n            {'K': 44.87523816, 'S': 18.39864105, 'O': 36.72612079}\n        \"\"\"\n        output = MolarMassCalculation(self.parsed_formula).calculate_mass_percent()\n        return round_dict_content(output, self.precision)\n\n    @property\n    @lru_cache(maxsize=1)\n    def atomic_percent(self) -&gt; dict[str, float]:\n        \"\"\"\n        Atomic percents of atoms in the formula.\n\n        Returns:\n            An atomic percent or \\\n            [relative mole fraction](https://en.wikipedia.org/wiki/Mole_fraction) \\\n            dictionary of atoms in a parsed chemical formula. \\\n            The values of mole content are in % (with 100% sum), \\\n            not fraction.\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").atomic_percent\n            {'K': 28.57142857, 'S': 14.28571429, 'O': 57.14285714}\n        \"\"\"\n        output = MolarMassCalculation(self.parsed_formula).calculate_atomic_percent()\n        return round_dict_content(output, self.precision)\n\n    @property\n    @lru_cache(maxsize=1)\n    def oxide_percent(self) -&gt; dict[str, float]:\n        \"\"\"\n        Oxide percents of metals in formula. Custom oxide formulas can be provided\n        with object init.\n\n        Returns:\n            An oxide percent or \\\n            [oxide fraction](https://d32ogoqmya1dw8.cloudfront.net/files/introgeo/studio/examples/minex02.pdf) \\\n            dictionary of atoms in parsed chemical formula. Oxide types are listed \\\n            in the [chemsynthcalc.periodic_table][] file and can be changed to \\\n            any oxide formula. The values of oxide content \\\n            are in % (with 100% sum), not fraction.\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").oxide_percent\n            {'K2O': 54.05676836, 'SO3': 45.94323164}\n            &gt;&gt;&gt; ChemicalFormula(\"K2FeO4\", \"FeO3\").oxide_percent\n            {'K2O': 47.56434404, 'FeO3': 52.43565596}\n        \"\"\"\n        output = MolarMassCalculation(self.parsed_formula).calculate_oxide_percent(\n            *self.custom_oxides\n        )\n        return round_dict_content(output, self.precision)\n\n    @property\n    @lru_cache(maxsize=1)\n    def output_results(self) -&gt; dict[str, object]:\n        \"\"\"\n        Dictionary of the calculation result output for class.\n\n        Returns:\n            Output dictionary for all properties listed above\n\n        Examples:\n            &gt;&gt;&gt; ChemicalFormula(\"K2SO4\").output_results\n            {'formula': 'K2SO4', 'parsed formula': {'K': 2.0, 'S': 1.0, 'O': 4.0},\n            'molar mass': 174.252, 'mass percent': {'K': 44.87523816, 'S': 18.39864105, 'O': 36.72612079},\n            'atomic percent': {'K': 28.57142857, 'S': 14.28571429, 'O': 57.14285714},\n            'oxide percent': {'K2O': 54.05676836, 'SO3': 45.94323164}}\n        \"\"\"\n        return {\n            \"formula\": self.formula,\n            \"parsed formula\": self.parsed_formula,\n            \"molar mass\": self.molar_mass,\n            \"mass percent\": self.mass_percent,\n            \"atomic percent\": self.atomic_percent,\n            \"oxide percent\": self.oxide_percent,\n        }\n\n    def print_results(self, print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Print a final result of calculations in stdout.\n\n        Arguments:\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).print_results()\n\n    def to_txt(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Export the final result of the calculations in a txt file.\n\n        Arguments:\n            filename (str): filename string (should end with .txt)\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).write_to_txt(filename)\n\n    def to_json(self, print_precision: int = 4) -&gt; str:\n        \"\"\"\n        Serialization of output into JSON object.\n\n        Arguments:\n            print_precision (int): print precision (4 digits by default)\n\n        Returns:\n            A JSON-type object\n        \"\"\"\n        return ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).dump_to_json()\n\n    def to_json_file(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Export a final result of calculations in a JSON file.\n\n        Arguments:\n            filename (str): filename string (should end with .json)\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).write_to_json_file(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.formula","title":"<code>formula</code>  <code>cached</code> <code>property</code>","text":"<p>A string of chemical formula. It is made a property to be relatively immutable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The formula string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").formula\nK2SO4\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.parsed_formula","title":"<code>parsed_formula</code>  <code>cached</code> <code>property</code>","text":"<p>Formula parsed into dictionary keeping the initial atom order.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Parsed dictionary representation of formula string created             by ChemicalFormulaParser</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").parsed_formula\n{'K': 2.0, 'S': 1.0, 'O': 4.0}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.molar_mass","title":"<code>molar_mass</code>  <code>cached</code> <code>property</code>","text":"<p>Molar mass of the compound.</p> <p>Returns:</p> Type Description <code>float</code> <p>The molar mass             of the formula (in g/mol), calculated from             parsed the formula using MolarMassCalculation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").molar_mass\n174.252\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.mass_percent","title":"<code>mass_percent</code>  <code>cached</code> <code>property</code>","text":"<p>The percentage of mass of atoms in the formula.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>A mass percent or             relative mass fraction             of atoms in parsed chemical formula. The values of             mass content are in % (with 100% sum), not fraction. </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").mass_percent\n{'K': 44.87523816, 'S': 18.39864105, 'O': 36.72612079}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.atomic_percent","title":"<code>atomic_percent</code>  <code>cached</code> <code>property</code>","text":"<p>Atomic percents of atoms in the formula.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>An atomic percent or             relative mole fraction             dictionary of atoms in a parsed chemical formula.             The values of mole content are in % (with 100% sum),             not fraction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").atomic_percent\n{'K': 28.57142857, 'S': 14.28571429, 'O': 57.14285714}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.oxide_percent","title":"<code>oxide_percent</code>  <code>cached</code> <code>property</code>","text":"<p>Oxide percents of metals in formula. Custom oxide formulas can be provided with object init.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>An oxide percent or             oxide fraction             dictionary of atoms in parsed chemical formula. Oxide types are listed             in the chemsynthcalc.periodic_table file and can be changed to             any oxide formula. The values of oxide content             are in % (with 100% sum), not fraction.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").oxide_percent\n{'K2O': 54.05676836, 'SO3': 45.94323164}\n&gt;&gt;&gt; ChemicalFormula(\"K2FeO4\", \"FeO3\").oxide_percent\n{'K2O': 47.56434404, 'FeO3': 52.43565596}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.output_results","title":"<code>output_results</code>  <code>cached</code> <code>property</code>","text":"<p>Dictionary of the calculation result output for class.</p> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>Output dictionary for all properties listed above</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalFormula(\"K2SO4\").output_results\n{'formula': 'K2SO4', 'parsed formula': {'K': 2.0, 'S': 1.0, 'O': 4.0},\n'molar mass': 174.252, 'mass percent': {'K': 44.87523816, 'S': 18.39864105, 'O': 36.72612079},\n'atomic percent': {'K': 28.57142857, 'S': 14.28571429, 'O': 57.14285714},\n'oxide percent': {'K2O': 54.05676836, 'SO3': 45.94323164}}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.print_results","title":"<code>print_results(print_precision=4)</code>","text":"<p>Print a final result of calculations in stdout.</p> <p>Parameters:</p> Name Type Description Default <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_formula.py</code> <pre><code>def print_results(self, print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Print a final result of calculations in stdout.\n\n    Arguments:\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).print_results()\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.to_txt","title":"<code>to_txt(filename='default', print_precision=4)</code>","text":"<p>Export the final result of the calculations in a txt file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .txt)</p> <code>'default'</code> <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_formula.py</code> <pre><code>def to_txt(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Export the final result of the calculations in a txt file.\n\n    Arguments:\n        filename (str): filename string (should end with .txt)\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).write_to_txt(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.to_json","title":"<code>to_json(print_precision=4)</code>","text":"<p>Serialization of output into JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON-type object</p> Source code in <code>src/chemsynthcalc/chemical_formula.py</code> <pre><code>def to_json(self, print_precision: int = 4) -&gt; str:\n    \"\"\"\n    Serialization of output into JSON object.\n\n    Arguments:\n        print_precision (int): print precision (4 digits by default)\n\n    Returns:\n        A JSON-type object\n    \"\"\"\n    return ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).dump_to_json()\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_formula.ChemicalFormula.to_json_file","title":"<code>to_json_file(filename='default', print_precision=4)</code>","text":"<p>Export a final result of calculations in a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .json)</p> <code>'default'</code> <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_formula.py</code> <pre><code>def to_json_file(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Export a final result of calculations in a JSON file.\n\n    Arguments:\n        filename (str): filename string (should end with .json)\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).write_to_json_file(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction","title":"<code>chemical_reaction</code>","text":""},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction","title":"<code>ChemicalReaction</code>","text":"<p>A class that represents a chemical reaction and do operations on it.</p> <p>There are three calculation modes:</p> <ol> <li> <p>The \"force\" mode is used when a user enters coefficients in the reaction string and wants the masses to be calculated whether the reaction is balanced or not.</p> </li> <li> <p>\"check\" mode is the same as force, but with reaction balance checks.</p> </li> <li> <p>\"balance\" mode  tries to automatically calculate coefficients from the reaction string.</p> </li> </ol> Important <p>Unlike other properties of this class, the coefficients property can be set directly.</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>str</code> <p>A reaction string</p> <code>''</code> <code>mode</code> <code>str</code> <p>Coefficients calculation mode</p> <code>'balance'</code> <code>target</code> <code>int</code> <p>Index of target compound (0 by default, or first compound in the products), can be negative (limited by reactant)</p> <code>0</code> <code>target_mass</code> <code>float</code> <p>Desired mass of target compound (in grams)</p> <code>1.0</code> <code>precision</code> <code>int</code> <p>Value of rounding precision (8 by default)</p> <code>8</code> <code>intify</code> <code>bool</code> <p>Is it required to convert the coefficients to integer values?</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>algorithm</code> <code>str</code> <p>Currently used calculation algorithm</p> Raise <p>ValueError if precision or target mass &lt;= 0</p> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>class ChemicalReaction:\n    \"\"\"\n    A class that represents a chemical reaction and do operations on it.\n\n    There are three calculation modes:\n\n    1. The \"force\" mode is used when a user enters coefficients\n    in the reaction string and wants the masses to be calculated\n    whether the reaction is balanced or not.\n\n    2. \"check\" mode is the same as force, but with reaction\n    balance checks.\n\n    3. \"balance\" mode  tries to automatically calculate\n    coefficients from the reaction string.\n\n    Important:\n        Unlike other properties of this class, the [coefficients][chemsynthcalc.chemical_reaction.ChemicalReaction.coefficients]\n        property can be set directly.\n\n    Arguments:\n        reaction (str): A reaction string\n        mode (str): Coefficients calculation mode\n        target (int): Index of target compound (0 by default, or first compound in the products), can be negative (limited by reactant)\n        target_mass (float): Desired mass of target compound (in grams)\n        precision (int): Value of rounding precision (8 by default)\n        intify (bool): Is it required to convert the coefficients to integer values?\n\n    Attributes:\n        algorithm (str): Currently used calculation algorithm\n\n    Raise:\n        ValueError if precision or target mass &lt;= 0\n    \"\"\"\n\n    def __init__(\n        self,\n        reaction: str = \"\",\n        mode: str = \"balance\",\n        target: int = 0,\n        target_mass: float = 1.0,\n        precision: int = 8,\n        intify: bool = True,\n    ) -&gt; None:\n        if ReactionValidator(reaction).validate_reaction():\n            self.initial_reaction = reaction.replace(\" \", \"\")\n\n        if precision &gt; 0:\n            self.precision: int = precision\n        else:\n            raise ValueError(\"precision &lt;= 0\")\n\n        if target_mass &gt; 0:\n            self.target_mass: float = target_mass\n        else:\n            raise ValueError(\"target mass &lt;= 0\")\n\n        self.intify: bool = intify\n        self.mode: str = mode\n        self.algorithm: str = \"user\"\n        self.initial_target: int = target\n\n    def __repr__(self) -&gt; str:\n        return f\"ChemicalReaction({self.reaction}, {self.mode}, {self.initial_target}, {self.target_mass}, {self.precision}, {self.intify})\"\n\n    def __str__(self) -&gt; str:\n        return self.reaction\n\n    @property\n    @lru_cache(maxsize=1)\n    def reaction(self) -&gt; str:\n        \"\"\"\n        A string of chemical reaction.\n        It is made a property to be relatively immutable.\n\n        Returns:\n            The reaction string\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").reaction\n            H2+O2=H2O\n        \"\"\"\n        return self.initial_reaction\n\n    @property\n    @lru_cache(maxsize=1)\n    def decomposed_reaction(self) -&gt; ReactionDecomposer:\n        \"\"\"\n        Decomposition of chemical reaction string and extraction of\n        reaction separator, reactants, products and initial coefficients.\n\n        Returns:\n            A ReactionDecomposer object\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").decomposed_reaction\n            separator: =; reactants: ['H2', 'O2']; products: ['H2O']\n        \"\"\"\n        return ReactionDecomposer(self.reaction)\n\n    @property\n    @lru_cache(maxsize=1)\n    def _calculated_target(self) -&gt; int:\n        \"\"\"\n        Checks if initial_target is in the reaction's compounds range,\n        and calculates the usable target integer.\n\n        Returns:\n            Final target\n\n        Raise:\n            IndexError if The target integer is not in the range\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\")._calculated_target\n            2\n        \"\"\"\n        high = len(self.decomposed_reaction.products) - 1\n        low = -len(self.decomposed_reaction.reactants)\n        if self.initial_target &lt;= high and self.initial_target &gt;= low:\n            return self.initial_target - low\n        else:\n            raise IndexError(\n                f\"The target integer {self.initial_target} should be in range {low} : {high}\"\n            )\n\n    @property\n    @lru_cache(maxsize=1)\n    def chemformula_objs(self) -&gt; list[ChemicalFormula]:\n        \"\"\"Decomposition of a list of formulas from the decomposed_reaction.\n\n        Returns:\n            Every compound as ChemicalFormula object\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").chemformula_objs\n            [ChemicalFormula('H2', 8), ChemicalFormula('O2', 8), ChemicalFormula('H2O', 8)]\n        \"\"\"\n        return [\n            ChemicalFormula(formula, precision=self.precision)\n            for formula in self.decomposed_reaction.compounds\n        ]\n\n    @property\n    @lru_cache(maxsize=1)\n    def parsed_formulas(self) -&gt; list[dict[str, float]]:\n        \"\"\"\n        List of formulas parsed by [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser]\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").parsed_formulas\n            [{'K': 1.0, 'Mn': 1.0, 'O': 4.0}, {'H': 1.0, 'Cl': 1.0}, {'Mn': 1.0, 'Cl': 2.0}, {'Cl': 2.0}, {'H': 2.0, 'O': 1.0}, {'K': 1.0, 'Cl': 1.0}]\n        \"\"\"\n        return [compound.parsed_formula for compound in self.chemformula_objs]\n\n    @property\n    @lru_cache(maxsize=1)\n    def matrix(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Chemical reaction matrix.\n\n        The first implementation of reaction matrix method is probably\n        belongs to [Blakley](https://doi.org/10.1021/ed059p728). In general,\n        a chemical reaction matrix is composed of the coefficients of each\n        atom in each compound, giving a 2D array. The matrix composes\n        naturally from previously parsed formulas.\n\n        Returns:\n            2D array of each atom amount in each formula\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").matrix\n            [[1. 0. 0. 0. 0. 1.]  (K)\n            [1. 0. 1. 0. 0. 0.]   (Mn)\n            [4. 0. 0. 0. 1. 0.]   (O)\n            [0. 1. 0. 0. 2. 0.]   (H)\n            [0. 1. 2. 2. 0. 1.]]  (Cl)\n        \"\"\"\n        return ChemicalReactionMatrix(self.parsed_formulas).matrix\n\n    @property\n    @lru_cache(maxsize=1)\n    def balancer(self) -&gt; Balancer:\n        \"\"\"\n        A balancer to  automatically balance chemical reaction by different matrix methods.\n\n        Returns:\n            A Balancer object\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").balancer\n            Balancer object for matrix\n            [[1. 0. 0. 0. 0. 1.]\n            [1. 0. 1. 0. 0. 0.]\n            [4. 0. 0. 0. 1. 0.]\n            [0. 1. 0. 0. 2. 0.]\n            [0. 1. 2. 2. 0. 1.]]\n        \"\"\"\n        return Balancer(\n            self.matrix,\n            len(self.decomposed_reaction.reactants),\n            self.precision,\n            intify=self.intify,\n        )\n\n    @property\n    @lru_cache(maxsize=1)\n    def molar_masses(self) -&gt; list[float]:\n        \"\"\"\n        List of molar masses (in g/mol)\n\n        Returns:\n            List of molar masses of each compound in [chemformula_objs][chemsynthcalc.chemical_reaction.ChemicalReaction.chemformula_objs]\"\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").molar_masses\n            [158.032043, 36.458, 125.838043, 70.9, 18.015, 74.548]\n        \"\"\"\n        return [compound.molar_mass for compound in self.chemformula_objs]\n\n    @cached_property\n    def coefficients(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        Coefficients of the chemical reaction. Can be calculated (balance mode),\n        striped off the initial reaction string (force or check modes) or set directly.\n\n        Returns:\n            A list of coefficients\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\", mode=\"balance\").coefficients\n            [2, 16, 2, 5, 8, 2]\n            &gt;&gt;&gt; reaction = ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\", mode=\"check\")\n            &gt;&gt;&gt; reaction.coefficients = [2, 16, 2, 5, 8, 2]\n            &gt;&gt;&gt; reaction.coefficients\n            [2, 16, 2, 5, 8, 2]\n            &gt;&gt;&gt; ChemicalReaction(\"2H2+2O2=H2O\", mode=\"force\").coefficients\n            [2, 2, 1]\n        \"\"\"\n        coefs, self.algorithm = Coefficients(\n            self.mode,\n            self.parsed_formulas,\n            self.matrix,\n            self.balancer,\n            self.decomposed_reaction,\n        ).get_coefficients()\n        return coefs\n\n    @property\n    @lru_cache(maxsize=1)\n    def normalized_coefficients(self) -&gt; list[float | int] | list[int]:\n        \"\"\"\n        List of coefficients normalized on target compound.\n\n        Target coefficient = 1.0\n\n        Returns:\n            Normalized coefficients\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").normalized_coefficients\n            [1, 8, 1, 2.5, 4, 1]\n        \"\"\"\n        Coefficients(\n            self.mode,\n            self.parsed_formulas,\n            self.matrix,\n            self.balancer,\n            self.decomposed_reaction,\n        ).coefficients_validation(self.coefficients)\n\n        target_compound = self.coefficients[self._calculated_target]\n        normalized_coefficients: list[float | int] | list[int] = [\n            coef / target_compound for coef in self.coefficients\n        ]\n        return [\n            int(i) if i.is_integer() else round(i, self.precision)\n            for i in normalized_coefficients\n        ]\n\n    @property\n    def is_balanced(self) -&gt; bool:\n        \"\"\"\n        Is the reaction balanced with the current coefficients?\n\n        Returns:\n            True if the reaction is balanced\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").is_balanced\n            True\n        \"\"\"\n        return Balancer.is_reaction_balanced(\n            self.balancer.reactant_matrix,\n            self.balancer.product_matrix,\n            self.coefficients,\n        )\n\n    def _generate_final_reaction(self, coefs: list[float | int] | list[int]) -&gt; str:\n        \"\"\"\n        Final reaction string with connotated formulas and calculated coefficients.\n\n        Parameters:\n            coefs ( list[float | int] | list[int]): list of coefficients\n\n        Returns:\n            String of the final reaction\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\")._generate_final_reaction([2, 16, 2, 5, 8, 2])\n            2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl\n        \"\"\"\n        final_reaction = [\n            (\n                str(coefs[i]) + str(compound)\n                if coefs[i] != 1 or coefs[i] != 1.0\n                else str(compound)\n            )\n            for i, compound in enumerate(self.decomposed_reaction.compounds)\n        ]\n        final_reaction = (self.decomposed_reaction.reactant_separator).join(\n            final_reaction\n        )\n        final_reaction = final_reaction.replace(\n            self.decomposed_reaction.reactants[-1]\n            + self.decomposed_reaction.reactant_separator,\n            self.decomposed_reaction.reactants[-1] + self.decomposed_reaction.separator,\n        )\n        return final_reaction\n\n    @property\n    @lru_cache(maxsize=1)\n    def final_reaction(self) -&gt; str:\n        \"\"\"\n        Final representation of the reaction with coefficients.\n\n        Returns:\n            A string of the final reaction\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").final_reaction\n            2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl\n        \"\"\"\n        return self._generate_final_reaction(self.coefficients)\n\n    @property\n    @lru_cache(maxsize=1)\n    def final_reaction_normalized(self) -&gt; str:\n        \"\"\"\n        Final representation of the reaction with normalized coefficients.\n\n        Returns:\n            A string of the normalized final reaction\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").final_reaction_normalized\n            KMnO4+8HCl=MnCl2+2.5Cl2+4H2O+KCl\n        \"\"\"\n        return self._generate_final_reaction(self.normalized_coefficients)\n\n    @property\n    @lru_cache(maxsize=1)\n    def masses(self) -&gt; list[float]:\n        \"\"\"\n        List of masses of compounds (in grams).\n\n        List of masses of the of formulas in reaction\n        calculated with coefficients obtained by any of the 3 methods.\n        Calculates masses by calculating amount of substance nu (nu=mass/molar mass).\n        Coefficients of reaction are normalized to the target. After nu of target compound is\n        calculated, it broadcasted to other compounds (with respect to their coefficients).\n\n        Returns:\n            A list of masses of compounds\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").masses\n            [1.25583678, 2.31777285, 1.0, 1.40855655, 0.57264082, 0.59241226]\n        \"\"\"\n        nu = self.target_mass / self.molar_masses[self._calculated_target]\n        masses = [\n            round(molar * nu * self.normalized_coefficients[i], self.precision)\n            for i, molar in enumerate(self.molar_masses)\n        ]\n        return masses\n\n    @property\n    @lru_cache(maxsize=1)\n    def output_results(self) -&gt; dict[str, object]:\n        \"\"\"\n        Collection of every output of calculated ChemicalReaction properties.\n\n        Returns:\n            All outputs collected in one dictionary.\n\n        Examples:\n            &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").output_results\n            {'initial reaction': 'KMnO4+HCl=MnCl2+Cl2+H2O+KCl',\n            'reaction matrix': array([[1., 0., 0., 0., 0., 1.],\n            [1., 0., 1., 0., 0., 0.],\n            [4., 0., 0., 0., 1., 0.],\n            [0., 1., 0., 0., 2., 0.],\n            [0., 1., 2., 2., 0., 1.]]),\n            'mode': 'balance',\n            'formulas': ['KMnO4', 'HCl', 'MnCl2', 'Cl2', 'H2O', 'KCl'],\n            'coefficients': [2, 16, 2, 5, 8, 2],\n            'normalized coefficients': [1, 8, 1, 2.5, 4, 1],\n            'algorithm': 'inverse',\n            'is balanced': True,\n            'final reaction': '2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl',\n            'final reaction normalized': 'KMnO4+8HCl=MnCl2+2.5Cl2+4H2O+KCl',\n            'molar masses': [158.032043, 36.458, 125.838043, 70.9, 18.015, 74.548],\n            'target': 'MnCl2',\n            'masses': [1.25583678, 2.31777285, 1.0, 1.40855655, 0.57264082, 0.59241226]}\n        \"\"\"\n        return {\n            \"initial reaction\": self.reaction,\n            \"reaction matrix\": self.matrix,\n            \"mode\": self.mode,\n            \"formulas\": self.decomposed_reaction.compounds,\n            \"coefficients\": self.coefficients,\n            \"normalized coefficients\": self.normalized_coefficients,\n            \"algorithm\": self.algorithm,\n            \"is balanced\": self.is_balanced,\n            \"final reaction\": self.final_reaction,\n            \"final reaction normalized\": self.final_reaction_normalized,\n            \"molar masses\": self.molar_masses,\n            \"target\": self.decomposed_reaction.compounds[self._calculated_target],\n            \"masses\": self.masses,\n        }\n\n    def print_results(self, print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Print a final result of calculations in stdout.\n\n        Arguments:\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).print_results()\n\n    def to_txt(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Export the final result of the calculations in a txt file.\n\n        Arguments:\n            filename (str): filename string (should end with .txt)\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).write_to_txt(filename)\n\n    def to_json(self, print_precision: int = 4) -&gt; str:\n        \"\"\"\n        Serialization of output into JSON object.\n\n        Arguments:\n            print_precision (int): print precision (4 digits by default)\n\n        Returns:\n            A JSON-type object\n        \"\"\"\n        return ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).dump_to_json()\n\n    def to_json_file(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n        \"\"\"\n        Export a final result of calculations in a JSON file.\n\n        Arguments:\n            filename (str): filename string (should end with .json)\n            print_precision (int): print precision (4 digits by default)\n        \"\"\"\n        ChemicalOutput(\n            self.output_results, print_precision, obj=self.__class__.__name__\n        ).write_to_json_file(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.reaction","title":"<code>reaction</code>  <code>cached</code> <code>property</code>","text":"<p>A string of chemical reaction. It is made a property to be relatively immutable.</p> <p>Returns:</p> Type Description <code>str</code> <p>The reaction string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").reaction\nH2+O2=H2O\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.decomposed_reaction","title":"<code>decomposed_reaction</code>  <code>cached</code> <code>property</code>","text":"<p>Decomposition of chemical reaction string and extraction of reaction separator, reactants, products and initial coefficients.</p> <p>Returns:</p> Type Description <code>ReactionDecomposer</code> <p>A ReactionDecomposer object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").decomposed_reaction\nseparator: =; reactants: ['H2', 'O2']; products: ['H2O']\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction._calculated_target","title":"<code>_calculated_target</code>  <code>cached</code> <code>property</code>","text":"<p>Checks if initial_target is in the reaction's compounds range, and calculates the usable target integer.</p> <p>Returns:</p> Type Description <code>int</code> <p>Final target</p> Raise <p>IndexError if The target integer is not in the range</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\")._calculated_target\n2\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.chemformula_objs","title":"<code>chemformula_objs</code>  <code>cached</code> <code>property</code>","text":"<p>Decomposition of a list of formulas from the decomposed_reaction.</p> <p>Returns:</p> Type Description <code>list[ChemicalFormula]</code> <p>Every compound as ChemicalFormula object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"H2+O2=H2O\").chemformula_objs\n[ChemicalFormula('H2', 8), ChemicalFormula('O2', 8), ChemicalFormula('H2O', 8)]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.parsed_formulas","title":"<code>parsed_formulas</code>  <code>cached</code> <code>property</code>","text":"<p>List of formulas parsed by ChemicalFormulaParser</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").parsed_formulas\n[{'K': 1.0, 'Mn': 1.0, 'O': 4.0}, {'H': 1.0, 'Cl': 1.0}, {'Mn': 1.0, 'Cl': 2.0}, {'Cl': 2.0}, {'H': 2.0, 'O': 1.0}, {'K': 1.0, 'Cl': 1.0}]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.matrix","title":"<code>matrix</code>  <code>cached</code> <code>property</code>","text":"<p>Chemical reaction matrix.</p> <p>The first implementation of reaction matrix method is probably belongs to Blakley. In general, a chemical reaction matrix is composed of the coefficients of each atom in each compound, giving a 2D array. The matrix composes naturally from previously parsed formulas.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>2D array of each atom amount in each formula</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").matrix\n[[1. 0. 0. 0. 0. 1.]  (K)\n[1. 0. 1. 0. 0. 0.]   (Mn)\n[4. 0. 0. 0. 1. 0.]   (O)\n[0. 1. 0. 0. 2. 0.]   (H)\n[0. 1. 2. 2. 0. 1.]]  (Cl)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.balancer","title":"<code>balancer</code>  <code>cached</code> <code>property</code>","text":"<p>A balancer to  automatically balance chemical reaction by different matrix methods.</p> <p>Returns:</p> Type Description <code>Balancer</code> <p>A Balancer object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").balancer\nBalancer object for matrix\n[[1. 0. 0. 0. 0. 1.]\n[1. 0. 1. 0. 0. 0.]\n[4. 0. 0. 0. 1. 0.]\n[0. 1. 0. 0. 2. 0.]\n[0. 1. 2. 2. 0. 1.]]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.molar_masses","title":"<code>molar_masses</code>  <code>cached</code> <code>property</code>","text":"<p>List of molar masses (in g/mol)</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>List of molar masses of each compound in chemformula_objs\"</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").molar_masses\n[158.032043, 36.458, 125.838043, 70.9, 18.015, 74.548]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.coefficients","title":"<code>coefficients</code>  <code>cached</code> <code>property</code>","text":"<p>Coefficients of the chemical reaction. Can be calculated (balance mode), striped off the initial reaction string (force or check modes) or set directly.</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>A list of coefficients</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\", mode=\"balance\").coefficients\n[2, 16, 2, 5, 8, 2]\n&gt;&gt;&gt; reaction = ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\", mode=\"check\")\n&gt;&gt;&gt; reaction.coefficients = [2, 16, 2, 5, 8, 2]\n&gt;&gt;&gt; reaction.coefficients\n[2, 16, 2, 5, 8, 2]\n&gt;&gt;&gt; ChemicalReaction(\"2H2+2O2=H2O\", mode=\"force\").coefficients\n[2, 2, 1]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.normalized_coefficients","title":"<code>normalized_coefficients</code>  <code>cached</code> <code>property</code>","text":"<p>List of coefficients normalized on target compound.</p> <p>Target coefficient = 1.0</p> <p>Returns:</p> Type Description <code>list[float | int] | list[int]</code> <p>Normalized coefficients</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").normalized_coefficients\n[1, 8, 1, 2.5, 4, 1]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.is_balanced","title":"<code>is_balanced</code>  <code>property</code>","text":"<p>Is the reaction balanced with the current coefficients?</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the reaction is balanced</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").is_balanced\nTrue\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.final_reaction","title":"<code>final_reaction</code>  <code>cached</code> <code>property</code>","text":"<p>Final representation of the reaction with coefficients.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string of the final reaction</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").final_reaction\n2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.final_reaction_normalized","title":"<code>final_reaction_normalized</code>  <code>cached</code> <code>property</code>","text":"<p>Final representation of the reaction with normalized coefficients.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string of the normalized final reaction</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").final_reaction_normalized\nKMnO4+8HCl=MnCl2+2.5Cl2+4H2O+KCl\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.masses","title":"<code>masses</code>  <code>cached</code> <code>property</code>","text":"<p>List of masses of compounds (in grams).</p> <p>List of masses of the of formulas in reaction calculated with coefficients obtained by any of the 3 methods. Calculates masses by calculating amount of substance nu (nu=mass/molar mass). Coefficients of reaction are normalized to the target. After nu of target compound is calculated, it broadcasted to other compounds (with respect to their coefficients).</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>A list of masses of compounds</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").masses\n[1.25583678, 2.31777285, 1.0, 1.40855655, 0.57264082, 0.59241226]\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.output_results","title":"<code>output_results</code>  <code>cached</code> <code>property</code>","text":"<p>Collection of every output of calculated ChemicalReaction properties.</p> <p>Returns:</p> Type Description <code>dict[str, object]</code> <p>All outputs collected in one dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\").output_results\n{'initial reaction': 'KMnO4+HCl=MnCl2+Cl2+H2O+KCl',\n'reaction matrix': array([[1., 0., 0., 0., 0., 1.],\n[1., 0., 1., 0., 0., 0.],\n[4., 0., 0., 0., 1., 0.],\n[0., 1., 0., 0., 2., 0.],\n[0., 1., 2., 2., 0., 1.]]),\n'mode': 'balance',\n'formulas': ['KMnO4', 'HCl', 'MnCl2', 'Cl2', 'H2O', 'KCl'],\n'coefficients': [2, 16, 2, 5, 8, 2],\n'normalized coefficients': [1, 8, 1, 2.5, 4, 1],\n'algorithm': 'inverse',\n'is balanced': True,\n'final reaction': '2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl',\n'final reaction normalized': 'KMnO4+8HCl=MnCl2+2.5Cl2+4H2O+KCl',\n'molar masses': [158.032043, 36.458, 125.838043, 70.9, 18.015, 74.548],\n'target': 'MnCl2',\n'masses': [1.25583678, 2.31777285, 1.0, 1.40855655, 0.57264082, 0.59241226]}\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction._generate_final_reaction","title":"<code>_generate_final_reaction(coefs)</code>","text":"<p>Final reaction string with connotated formulas and calculated coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coefs</code> <code> list[float | int] | list[int]</code> <p>list of coefficients</p> required <p>Returns:</p> Type Description <code>str</code> <p>String of the final reaction</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\")._generate_final_reaction([2, 16, 2, 5, 8, 2])\n2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl\n</code></pre> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>def _generate_final_reaction(self, coefs: list[float | int] | list[int]) -&gt; str:\n    \"\"\"\n    Final reaction string with connotated formulas and calculated coefficients.\n\n    Parameters:\n        coefs ( list[float | int] | list[int]): list of coefficients\n\n    Returns:\n        String of the final reaction\n\n    Examples:\n        &gt;&gt;&gt; ChemicalReaction(\"KMnO4+HCl=MnCl2+Cl2+H2O+KCl\")._generate_final_reaction([2, 16, 2, 5, 8, 2])\n        2KMnO4+16HCl=2MnCl2+5Cl2+8H2O+2KCl\n    \"\"\"\n    final_reaction = [\n        (\n            str(coefs[i]) + str(compound)\n            if coefs[i] != 1 or coefs[i] != 1.0\n            else str(compound)\n        )\n        for i, compound in enumerate(self.decomposed_reaction.compounds)\n    ]\n    final_reaction = (self.decomposed_reaction.reactant_separator).join(\n        final_reaction\n    )\n    final_reaction = final_reaction.replace(\n        self.decomposed_reaction.reactants[-1]\n        + self.decomposed_reaction.reactant_separator,\n        self.decomposed_reaction.reactants[-1] + self.decomposed_reaction.separator,\n    )\n    return final_reaction\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.print_results","title":"<code>print_results(print_precision=4)</code>","text":"<p>Print a final result of calculations in stdout.</p> <p>Parameters:</p> Name Type Description Default <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>def print_results(self, print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Print a final result of calculations in stdout.\n\n    Arguments:\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).print_results()\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.to_txt","title":"<code>to_txt(filename='default', print_precision=4)</code>","text":"<p>Export the final result of the calculations in a txt file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .txt)</p> <code>'default'</code> <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>def to_txt(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Export the final result of the calculations in a txt file.\n\n    Arguments:\n        filename (str): filename string (should end with .txt)\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).write_to_txt(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.to_json","title":"<code>to_json(print_precision=4)</code>","text":"<p>Serialization of output into JSON object.</p> <p>Parameters:</p> Name Type Description Default <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> <p>Returns:</p> Type Description <code>str</code> <p>A JSON-type object</p> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>def to_json(self, print_precision: int = 4) -&gt; str:\n    \"\"\"\n    Serialization of output into JSON object.\n\n    Arguments:\n        print_precision (int): print precision (4 digits by default)\n\n    Returns:\n        A JSON-type object\n    \"\"\"\n    return ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).dump_to_json()\n</code></pre>"},{"location":"API/#chemsynthcalc.chemical_reaction.ChemicalReaction.to_json_file","title":"<code>to_json_file(filename='default', print_precision=4)</code>","text":"<p>Export a final result of calculations in a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>filename string (should end with .json)</p> <code>'default'</code> <code>print_precision</code> <code>int</code> <p>print precision (4 digits by default)</p> <code>4</code> Source code in <code>src/chemsynthcalc/chemical_reaction.py</code> <pre><code>def to_json_file(self, filename: str = \"default\", print_precision: int = 4) -&gt; None:\n    \"\"\"\n    Export a final result of calculations in a JSON file.\n\n    Arguments:\n        filename (str): filename string (should end with .json)\n        print_precision (int): print precision (4 digits by default)\n    \"\"\"\n    ChemicalOutput(\n        self.output_results, print_precision, obj=self.__class__.__name__\n    ).write_to_json_file(filename)\n</code></pre>"},{"location":"API/#chemsynthcalc.coefs","title":"<code>coefs</code>","text":""},{"location":"API/#chemsynthcalc.coefs.Coefficients","title":"<code>Coefficients</code>","text":"<p>A class to calculate and validate reaction coefficients depending on the calculation \"mode\".</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Calculation mode (\"force\", \"check\", \"balance\")</p> required <code>parsed_formulas</code> <code>list[dict[str, float]]</code> <p>List of formulas parsed by ChemicalFormulaParser</p> required <code>matrix</code> <code>NDArray[float64]</code> <p>Reaction matrix created by ChemicalReactionMatrix</p> required <code>balancer</code> <code>Balancer</code> <p>A Balancer object</p> required <code>decomposed_reaction</code> <code>ReactionDecomposer</code> <p>A ReactionDecomposer object</p> required <p>Attributes:</p> Name Type Description <code>initial_coefficients</code> <code>list[float]</code> <p>List of initial coefficients from decomposed reaction</p> Source code in <code>src/chemsynthcalc/coefs.py</code> <pre><code>class Coefficients:\n    \"\"\"\n    A class to calculate and validate reaction coefficients depending on the calculation \"mode\".\n\n    Arguments:\n        mode (str): Calculation mode (\"force\", \"check\", \"balance\")\n        parsed_formulas (list[dict[str, float]]): List of formulas parsed by [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser]\n        matrix (npt.NDArray[np.float64]): Reaction matrix created by [ChemicalReactionMatrix][chemsynthcalc.reaction_matrix.ChemicalReactionMatrix]\n        balancer (Balancer): A [Balancer][chemsynthcalc.balancer.Balancer] object\n        decomposed_reaction (ReactionDecomposer): A [ReactionDecomposer][chemsynthcalc.reaction_decomposer.ReactionDecomposer] object\n\n    Attributes:\n        initial_coefficients (list[float]): List of initial coefficients from decomposed reaction\n    \"\"\"\n\n    def __init__(\n        self,\n        mode: str,\n        parsed_formulas: list[dict[str, float]],\n        matrix: npt.NDArray[np.float64],\n        balancer: Balancer,\n        decomposed_reaction: ReactionDecomposer,\n    ) -&gt; None:\n        self.mode = mode\n        self.matrix = matrix\n        self.balancer = balancer\n        self.initial_coefficients = decomposed_reaction.initial_coefficients\n        self.decomposed_reaction = decomposed_reaction\n        self.parsed_formulas = parsed_formulas\n\n    def _calculate_coefficients(self) -&gt; tuple[list[float | int] | list[int], str]:\n        \"\"\"\n        Match a mode string and get coefficients depending on the mode\n\n        Returns:\n            Tuple of (coefficients, algorithm)\n\n        Raise:\n            [ReactionNotBalanced][chemsynthcalc.chem_errors.ReactionNotBalanced] if reaction is not balanced in the \"check\" mode &lt;br /&gt;\n            [NoSuchMode][chemsynthcalc.chem_errors.NoSuchMode] if there is no mode with that name\n        \"\"\"\n        match self.mode:\n\n            case \"force\":\n                return (\n                    to_integer(self.decomposed_reaction.initial_coefficients),\n                    \"user\",\n                )\n\n            case \"check\":\n                if Balancer.is_reaction_balanced(\n                    self.balancer.reactant_matrix,\n                    self.balancer.product_matrix,\n                    self.decomposed_reaction.initial_coefficients,\n                ):\n                    return (\n                        to_integer(self.decomposed_reaction.initial_coefficients),\n                        \"user\",\n                    )\n                else:\n                    raise ReactionNotBalanced(\"This reaction is not balanced!\")\n\n            case \"balance\":\n                coefs, algorithm = self.balancer.auto()\n                return (coefs, algorithm)\n\n            case _:\n                raise NoSuchMode(f\"No mode {self.mode}\")\n\n    def coefficients_validation(\n        self, coefficients: list[float | int] | list[int]\n    ) -&gt; None:\n        \"\"\"\n        Validate a list of coefs.\n\n        Arguments:\n            coefficients (list[float | int] | list[int]): List of coefs\n\n        Raise:\n            [BadCoeffiecients][chemsynthcalc.chem_errors.BadCoeffiecients] if any coef &lt;= 0 or\n            lenght of list is not equal to the number of compounds.\n        \"\"\"\n        if any(x &lt;= 0 for x in coefficients):\n            raise BadCoeffiecients(\"0 or -x in coefficients\")\n        elif len(coefficients) != self.matrix.shape[1]:\n            raise BadCoeffiecients(\n                f\"Number of coefficients should be equal to {self.matrix.shape[1]}\"\n            )\n\n    def _element_count_validation(self) -&gt; None:\n        \"\"\"\n        Calculate a [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n        of two sets - left and right parts of the reaction. If this set is not empty, than\n        some atoms are only in one part of the reaction (which is impossible).\n\n        Raise:\n            [ReactantProductDifference][chemsynthcalc.chem_errors.ReactantProductDifference] if diff set is not empty.\n        \"\"\"\n        if self.mode != \"force\":\n            reactants = {\n                k: v\n                for d in self.parsed_formulas[: len(self.decomposed_reaction.reactants)]\n                for k, v in d.items()\n            }\n            products = {\n                k: v\n                for d in self.parsed_formulas[len(self.decomposed_reaction.reactants) :]\n                for k, v in d.items()\n            }\n            diff = set(reactants.keys()) ^ (set(products.keys()))\n            if diff:\n                raise ReactantProductDifference(\n                    f\"Cannot balance this reaction, because element(s) {diff} are only in one part of the reaction\"\n                )\n\n    def get_coefficients(self) -&gt; tuple[list[float | int] | list[int], str]:\n        \"\"\"\n        Validate atom's diff and coefs list and finally get a proper coefficients list.\n\n        Returns:\n            Tuple of (coefficients, algorithm)\n        \"\"\"\n        self._element_count_validation()\n        coefs = self._calculate_coefficients()\n        self.coefficients_validation(coefs[0])\n        return coefs\n</code></pre>"},{"location":"API/#chemsynthcalc.coefs.Coefficients._calculate_coefficients","title":"<code>_calculate_coefficients()</code>","text":"<p>Match a mode string and get coefficients depending on the mode</p> <p>Returns:</p> Type Description <code>tuple[list[float | int] | list[int], str]</code> <p>Tuple of (coefficients, algorithm)</p> Raise <p>ReactionNotBalanced if reaction is not balanced in the \"check\" mode  NoSuchMode if there is no mode with that name</p> Source code in <code>src/chemsynthcalc/coefs.py</code> <pre><code>def _calculate_coefficients(self) -&gt; tuple[list[float | int] | list[int], str]:\n    \"\"\"\n    Match a mode string and get coefficients depending on the mode\n\n    Returns:\n        Tuple of (coefficients, algorithm)\n\n    Raise:\n        [ReactionNotBalanced][chemsynthcalc.chem_errors.ReactionNotBalanced] if reaction is not balanced in the \"check\" mode &lt;br /&gt;\n        [NoSuchMode][chemsynthcalc.chem_errors.NoSuchMode] if there is no mode with that name\n    \"\"\"\n    match self.mode:\n\n        case \"force\":\n            return (\n                to_integer(self.decomposed_reaction.initial_coefficients),\n                \"user\",\n            )\n\n        case \"check\":\n            if Balancer.is_reaction_balanced(\n                self.balancer.reactant_matrix,\n                self.balancer.product_matrix,\n                self.decomposed_reaction.initial_coefficients,\n            ):\n                return (\n                    to_integer(self.decomposed_reaction.initial_coefficients),\n                    \"user\",\n                )\n            else:\n                raise ReactionNotBalanced(\"This reaction is not balanced!\")\n\n        case \"balance\":\n            coefs, algorithm = self.balancer.auto()\n            return (coefs, algorithm)\n\n        case _:\n            raise NoSuchMode(f\"No mode {self.mode}\")\n</code></pre>"},{"location":"API/#chemsynthcalc.coefs.Coefficients.coefficients_validation","title":"<code>coefficients_validation(coefficients)</code>","text":"<p>Validate a list of coefs.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>list[float | int] | list[int]</code> <p>List of coefs</p> required Raise <p>BadCoeffiecients if any coef &lt;= 0 or lenght of list is not equal to the number of compounds.</p> Source code in <code>src/chemsynthcalc/coefs.py</code> <pre><code>def coefficients_validation(\n    self, coefficients: list[float | int] | list[int]\n) -&gt; None:\n    \"\"\"\n    Validate a list of coefs.\n\n    Arguments:\n        coefficients (list[float | int] | list[int]): List of coefs\n\n    Raise:\n        [BadCoeffiecients][chemsynthcalc.chem_errors.BadCoeffiecients] if any coef &lt;= 0 or\n        lenght of list is not equal to the number of compounds.\n    \"\"\"\n    if any(x &lt;= 0 for x in coefficients):\n        raise BadCoeffiecients(\"0 or -x in coefficients\")\n    elif len(coefficients) != self.matrix.shape[1]:\n        raise BadCoeffiecients(\n            f\"Number of coefficients should be equal to {self.matrix.shape[1]}\"\n        )\n</code></pre>"},{"location":"API/#chemsynthcalc.coefs.Coefficients._element_count_validation","title":"<code>_element_count_validation()</code>","text":"<p>Calculate a symmetric difference of two sets - left and right parts of the reaction. If this set is not empty, than some atoms are only in one part of the reaction (which is impossible).</p> Raise <p>ReactantProductDifference if diff set is not empty.</p> Source code in <code>src/chemsynthcalc/coefs.py</code> <pre><code>def _element_count_validation(self) -&gt; None:\n    \"\"\"\n    Calculate a [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n    of two sets - left and right parts of the reaction. If this set is not empty, than\n    some atoms are only in one part of the reaction (which is impossible).\n\n    Raise:\n        [ReactantProductDifference][chemsynthcalc.chem_errors.ReactantProductDifference] if diff set is not empty.\n    \"\"\"\n    if self.mode != \"force\":\n        reactants = {\n            k: v\n            for d in self.parsed_formulas[: len(self.decomposed_reaction.reactants)]\n            for k, v in d.items()\n        }\n        products = {\n            k: v\n            for d in self.parsed_formulas[len(self.decomposed_reaction.reactants) :]\n            for k, v in d.items()\n        }\n        diff = set(reactants.keys()) ^ (set(products.keys()))\n        if diff:\n            raise ReactantProductDifference(\n                f\"Cannot balance this reaction, because element(s) {diff} are only in one part of the reaction\"\n            )\n</code></pre>"},{"location":"API/#chemsynthcalc.coefs.Coefficients.get_coefficients","title":"<code>get_coefficients()</code>","text":"<p>Validate atom's diff and coefs list and finally get a proper coefficients list.</p> <p>Returns:</p> Type Description <code>tuple[list[float | int] | list[int], str]</code> <p>Tuple of (coefficients, algorithm)</p> Source code in <code>src/chemsynthcalc/coefs.py</code> <pre><code>def get_coefficients(self) -&gt; tuple[list[float | int] | list[int], str]:\n    \"\"\"\n    Validate atom's diff and coefs list and finally get a proper coefficients list.\n\n    Returns:\n        Tuple of (coefficients, algorithm)\n    \"\"\"\n    self._element_count_validation()\n    coefs = self._calculate_coefficients()\n    self.coefficients_validation(coefs[0])\n    return coefs\n</code></pre>"},{"location":"API/#chemsynthcalc.formula","title":"<code>formula</code>","text":""},{"location":"API/#chemsynthcalc.formula.Formula","title":"<code>Formula</code>","text":"<p>A base class for ChemicalFormulaParser and FormulaValidator containing regexes and symbols.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Formula string</p> required <p>Attributes:</p> Name Type Description <code>atom_regex</code> <code>str</code> <p>Regular expression for finding atoms in formula</p> <code>coefficient_regex</code> <code>str</code> <p>Regular expression for atoms amounts in formula</p> <code>atom_and_coefficient_regex</code> <code>str</code> <p>atom_regex+coefficient_regex</p> <code>opener_brackets</code> <code>str</code> <p>Opener brackets variations</p> <code>closer_brackets</code> <code>str</code> <p>Closer brackets variations</p> <code>adduct_symbols</code> <code>str</code> <p>Symbols for adduct notation (water of crystallization most often)</p> Source code in <code>src/chemsynthcalc/formula.py</code> <pre><code>class Formula:\n    \"\"\"\n    A base class for\n    [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser] and\n    [FormulaValidator][chemsynthcalc.formula_validator.FormulaValidator]\n    containing regexes and symbols.\n\n    Parameters:\n        formula (str): Formula string\n\n    Attributes:\n        atom_regex (str): Regular expression for finding atoms in formula\n        coefficient_regex (str): Regular expression for atoms amounts in formula\n        atom_and_coefficient_regex (str): atom_regex+coefficient_regex\n        opener_brackets (str): Opener brackets variations\n        closer_brackets (str): Closer brackets variations\n        adduct_symbols (str): Symbols for adduct notation (water of crystallization most often)\n    \"\"\"\n\n    def __init__(self, formula: str) -&gt; None:\n        self.atom_regex: str = r\"([A-Z][a-z]*)\"\n        self.coefficient_regex: str = r\"((\\d+(\\.\\d+)?)*)\"\n        self.allowed_symbols: str = r\"[^A-Za-z0-9.({[)}\\]*\u00b7\u2022]\"\n        self.atom_and_coefficient_regex: str = self.atom_regex + self.coefficient_regex\n        self.opener_brackets: str = \"({[\"\n        self.closer_brackets: str = \")}]\"\n        self.adduct_symbols: str = \"*\u00b7\u2022\"\n\n        self.formula: str = formula.replace(\" \", \"\")\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser","title":"<code>formula_parser</code>","text":""},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser","title":"<code>ChemicalFormulaParser</code>","text":"<p>               Bases: <code>Formula</code></p> <p>Parser of chemical formulas.</p> <p>Methods of this class take string of compound's chemical formula and turn it into a dict of atoms as keys and their coefficients as values.</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>class ChemicalFormulaParser(Formula):\n    \"\"\"\n    Parser of chemical formulas.\n\n    Methods of this class take string of compound's chemical formula\n    and turn it into a dict of atoms as keys and their coefficients as values.\n    \"\"\"\n\n    def _dictify(self, tuples: list[tuple[str, ...]]) -&gt; dict[str, float]:\n        \"\"\"\n        Transform list of tuples to a dict of atoms.\n\n        Parameters:\n            tuples (list[tuple[str, ...]]): List of tuples of atoms\n\n        Returns:\n            Dictionary of atoms and they quantities\n        \"\"\"\n\n        result: dict[str, float] = dict()\n        for atom, n, _, _ in tuples:\n            try:\n                result[atom] += float(n or 1)\n            except KeyError:\n                result[atom] = float(n or 1)\n        return result\n\n    def _fuse(\n        self, mol1: dict[str, float], mol2: dict[str, float], weight: float = 1.0\n    ) -&gt; dict[str, float]:\n        \"\"\"Fuse together 2 dicts representing molecules.\n\n        Parameters:\n            mol1 (dict[str, float]): Dict of atoms 1\n            mol2 (dict[str, float]): Dict of atoms 2\n            weight (float): Weight\n\n        Returns:\n            A new fused dict\n        \"\"\"\n\n        fused_set: set[str] = set(mol1) | set(mol2)\n        fused_dict: dict[str, float] = {\n            atom: (mol1.get(atom, 0) + mol2.get(atom, 0)) * weight for atom in fused_set\n        }\n\n        return fused_dict\n\n    def _parse(self, formula: str) -&gt; tuple[dict[str, float], int]:\n        \"\"\"\n        Parse the formula string\n\n        Recurse on opening brackets to parse the subpart and\n        return on closing ones because it is the end of said subpart.\n        Formula is the argument of this method due to the complications\n        of self. Constructions in recursive functions.\n\n        Parameters:\n            formula (str): Formula string\n\n        Returns:\n            A tuple of the molecule dict and length of parsed part\n        \"\"\"\n        token_list: list[str] = []\n        mol: dict[str, float] = {}\n        i: int = 0\n\n        while i &lt; len(formula):\n            token: str = formula[i]\n\n            if token in self.adduct_symbols:\n                coefficient_match: re.Match[str] | None = re.match(\n                    self.coefficient_regex, formula[i + 1 :]\n                )\n                if coefficient_match and coefficient_match.group(0) != \"\":\n                    weight: float = float(coefficient_match.group(0))\n                    i += len(coefficient_match.group(0))\n                else:\n                    weight = 1.0\n                recursive_dive: tuple[dict[str, float], int] = self._parse(\n                    f\"({formula[i + 1 :]}){weight}\"\n                )\n                submol = recursive_dive[0]\n                lenght: int = recursive_dive[1]\n                mol = self._fuse(mol, submol)\n                i += lenght + 1\n\n            elif token in self.closer_brackets:\n                coefficient_match: re.Match[str] | None = re.match(\n                    self.coefficient_regex, formula[i + 1 :]\n                )\n                if coefficient_match and coefficient_match.group(0) != \"\":\n                    weight: float = float(coefficient_match.group(0))\n                    i += len(coefficient_match.group(0))\n                else:\n                    weight = 1.0\n                submol: dict[str, float] = self._dictify(\n                    re.findall(self.atom_and_coefficient_regex, \"\".join(token_list))\n                )\n                return self._fuse(mol, submol, weight), i\n\n            elif token in self.opener_brackets:\n                recursive_dive: tuple[dict[str, float], int] = self._parse(\n                    formula[i + 1 :]\n                )\n                submol = recursive_dive[0]\n                lenght: int = recursive_dive[1]\n                mol = self._fuse(mol, submol)\n                i += lenght + 1\n\n            else:\n                token_list.append(token)\n\n            i += 1\n\n        extract_from_tokens: list[tuple[str, ...]] = re.findall(\n            self.atom_and_coefficient_regex, \"\".join(token_list)\n        )\n        fused_dict: dict[str, float] = self._fuse(\n            mol, self._dictify(extract_from_tokens)\n        )\n        return fused_dict, i\n\n    def _order_output_dict(self, parsed: dict[str, float]) -&gt; dict[str, float]:\n        \"\"\"\n        Arranges the unparsed formula in the order in which the chemical\n        elements appear in it.\n\n        Parameters:\n            parsed (dict[str, float]): A formula parsed by [_parse][chemsynthcalc.formula_parser.ChemicalFormulaParser._parse]\n\n        Returns:\n            An ordered dictionary\n        \"\"\"\n        atoms_list: list[str] = re.findall(self.atom_regex, self.formula)\n        weights: list[float] = []\n        for atom in atoms_list:\n            weights.append(parsed[atom])\n        return dict(zip(atoms_list, weights))\n\n    def parse_formula(self) -&gt; dict[str, float]:\n        \"\"\"\n        Parsing and ordering of formula\n\n        Returns:\n            Parsed formula\n        \"\"\"\n        parsed = self._parse(self.formula)[0]\n        return self._order_output_dict(parsed)\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser._dictify","title":"<code>_dictify(tuples)</code>","text":"<p>Transform list of tuples to a dict of atoms.</p> <p>Parameters:</p> Name Type Description Default <code>tuples</code> <code>list[tuple[str, ...]]</code> <p>List of tuples of atoms</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Dictionary of atoms and they quantities</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>def _dictify(self, tuples: list[tuple[str, ...]]) -&gt; dict[str, float]:\n    \"\"\"\n    Transform list of tuples to a dict of atoms.\n\n    Parameters:\n        tuples (list[tuple[str, ...]]): List of tuples of atoms\n\n    Returns:\n        Dictionary of atoms and they quantities\n    \"\"\"\n\n    result: dict[str, float] = dict()\n    for atom, n, _, _ in tuples:\n        try:\n            result[atom] += float(n or 1)\n        except KeyError:\n            result[atom] = float(n or 1)\n    return result\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser._fuse","title":"<code>_fuse(mol1, mol2, weight=1.0)</code>","text":"<p>Fuse together 2 dicts representing molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mol1</code> <code>dict[str, float]</code> <p>Dict of atoms 1</p> required <code>mol2</code> <code>dict[str, float]</code> <p>Dict of atoms 2</p> required <code>weight</code> <code>float</code> <p>Weight</p> <code>1.0</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>A new fused dict</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>def _fuse(\n    self, mol1: dict[str, float], mol2: dict[str, float], weight: float = 1.0\n) -&gt; dict[str, float]:\n    \"\"\"Fuse together 2 dicts representing molecules.\n\n    Parameters:\n        mol1 (dict[str, float]): Dict of atoms 1\n        mol2 (dict[str, float]): Dict of atoms 2\n        weight (float): Weight\n\n    Returns:\n        A new fused dict\n    \"\"\"\n\n    fused_set: set[str] = set(mol1) | set(mol2)\n    fused_dict: dict[str, float] = {\n        atom: (mol1.get(atom, 0) + mol2.get(atom, 0)) * weight for atom in fused_set\n    }\n\n    return fused_dict\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser._parse","title":"<code>_parse(formula)</code>","text":"<p>Parse the formula string</p> <p>Recurse on opening brackets to parse the subpart and return on closing ones because it is the end of said subpart. Formula is the argument of this method due to the complications of self. Constructions in recursive functions.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Formula string</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, float], int]</code> <p>A tuple of the molecule dict and length of parsed part</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>def _parse(self, formula: str) -&gt; tuple[dict[str, float], int]:\n    \"\"\"\n    Parse the formula string\n\n    Recurse on opening brackets to parse the subpart and\n    return on closing ones because it is the end of said subpart.\n    Formula is the argument of this method due to the complications\n    of self. Constructions in recursive functions.\n\n    Parameters:\n        formula (str): Formula string\n\n    Returns:\n        A tuple of the molecule dict and length of parsed part\n    \"\"\"\n    token_list: list[str] = []\n    mol: dict[str, float] = {}\n    i: int = 0\n\n    while i &lt; len(formula):\n        token: str = formula[i]\n\n        if token in self.adduct_symbols:\n            coefficient_match: re.Match[str] | None = re.match(\n                self.coefficient_regex, formula[i + 1 :]\n            )\n            if coefficient_match and coefficient_match.group(0) != \"\":\n                weight: float = float(coefficient_match.group(0))\n                i += len(coefficient_match.group(0))\n            else:\n                weight = 1.0\n            recursive_dive: tuple[dict[str, float], int] = self._parse(\n                f\"({formula[i + 1 :]}){weight}\"\n            )\n            submol = recursive_dive[0]\n            lenght: int = recursive_dive[1]\n            mol = self._fuse(mol, submol)\n            i += lenght + 1\n\n        elif token in self.closer_brackets:\n            coefficient_match: re.Match[str] | None = re.match(\n                self.coefficient_regex, formula[i + 1 :]\n            )\n            if coefficient_match and coefficient_match.group(0) != \"\":\n                weight: float = float(coefficient_match.group(0))\n                i += len(coefficient_match.group(0))\n            else:\n                weight = 1.0\n            submol: dict[str, float] = self._dictify(\n                re.findall(self.atom_and_coefficient_regex, \"\".join(token_list))\n            )\n            return self._fuse(mol, submol, weight), i\n\n        elif token in self.opener_brackets:\n            recursive_dive: tuple[dict[str, float], int] = self._parse(\n                formula[i + 1 :]\n            )\n            submol = recursive_dive[0]\n            lenght: int = recursive_dive[1]\n            mol = self._fuse(mol, submol)\n            i += lenght + 1\n\n        else:\n            token_list.append(token)\n\n        i += 1\n\n    extract_from_tokens: list[tuple[str, ...]] = re.findall(\n        self.atom_and_coefficient_regex, \"\".join(token_list)\n    )\n    fused_dict: dict[str, float] = self._fuse(\n        mol, self._dictify(extract_from_tokens)\n    )\n    return fused_dict, i\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser._order_output_dict","title":"<code>_order_output_dict(parsed)</code>","text":"<p>Arranges the unparsed formula in the order in which the chemical elements appear in it.</p> <p>Parameters:</p> Name Type Description Default <code>parsed</code> <code>dict[str, float]</code> <p>A formula parsed by _parse</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>An ordered dictionary</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>def _order_output_dict(self, parsed: dict[str, float]) -&gt; dict[str, float]:\n    \"\"\"\n    Arranges the unparsed formula in the order in which the chemical\n    elements appear in it.\n\n    Parameters:\n        parsed (dict[str, float]): A formula parsed by [_parse][chemsynthcalc.formula_parser.ChemicalFormulaParser._parse]\n\n    Returns:\n        An ordered dictionary\n    \"\"\"\n    atoms_list: list[str] = re.findall(self.atom_regex, self.formula)\n    weights: list[float] = []\n    for atom in atoms_list:\n        weights.append(parsed[atom])\n    return dict(zip(atoms_list, weights))\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_parser.ChemicalFormulaParser.parse_formula","title":"<code>parse_formula()</code>","text":"<p>Parsing and ordering of formula</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Parsed formula</p> Source code in <code>src/chemsynthcalc/formula_parser.py</code> <pre><code>def parse_formula(self) -&gt; dict[str, float]:\n    \"\"\"\n    Parsing and ordering of formula\n\n    Returns:\n        Parsed formula\n    \"\"\"\n    parsed = self._parse(self.formula)[0]\n    return self._order_output_dict(parsed)\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator","title":"<code>formula_validator</code>","text":""},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator","title":"<code>FormulaValidator</code>","text":"<p>               Bases: <code>Formula</code></p> <p>Methods of this class validate the initial input formula.</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>class FormulaValidator(Formula):\n    \"\"\"\n    Methods of this class validate the initial input formula.\n    \"\"\"\n\n    def _check_empty_formula(self) -&gt; bool:\n        \"\"\"\n        Checks if formula is an empty string.\n        \"\"\"\n        return self.formula == \"\"\n\n    def _invalid_charachers(self) -&gt; list[str]:\n        \"\"\"\n        Checks if formula contains invalid characters.\n\n        Returns:\n            List of invalid characters\n        \"\"\"\n        return re.compile(self.allowed_symbols).findall(self.formula)\n\n    def _invalid_atoms(self) -&gt; list[str]:\n        \"\"\"\n        Checks whether the formula contains atoms that\n        are not in the periodic system.\n\n        Returns:\n            List of invalid atoms\n        \"\"\"\n        atoms_list: list[str] = re.findall(self.atom_regex, self.formula)\n        invalid: list[str] = []\n        new_string: str = self.formula\n        # a trick to get Cl first of C in cases like CCl4\n        atoms_list = sorted(list(set(atoms_list)), key=len, reverse=True)\n        for atom in atoms_list:\n            if atom not in PeriodicTable().atoms:\n                invalid.append(atom)\n            new_string = new_string.replace(atom, \"\")\n        found_leftovers: list[str] = re.findall(r\"[a-z]\", new_string)\n        invalid.extend(found_leftovers)\n        return invalid\n\n    def _bracket_balance(self) -&gt; bool:\n        \"\"\"\n        Checks whether all of the brackets come in pairs.\n        \"\"\"\n        c: Counter[str] = Counter(self.formula)\n        for i in range(len(self.opener_brackets)):\n            if c[self.opener_brackets[i]] != c[self.closer_brackets[i]]:\n                return False\n        return True\n\n    def _num_of_adducts(self) -&gt; int:\n        \"\"\"\n        Counts a number of adduct symbols\n        (listed in [Formula base class][chemsynthcalc.formula.Formula]).\n\n        Returns:\n            A number of adduct symbols\n        \"\"\"\n        c: Counter[str] = Counter(self.formula)\n        i: int = 0\n        for adduct in self.adduct_symbols:\n            i += c[adduct]\n        return i\n\n    def validate_formula(self) -&gt; bool:\n        \"\"\"\n        Validation of the formula string.\n        Calls the private methods of this class in order.\n\n        Raise:\n            [EmptyFormula][chemsynthcalc.chem_errors.EmptyFormula] if the formula is an empty string. &lt;br /&gt;\n            [InvalidCharacter][chemsynthcalc.chem_errors.InvalidCharacter] if there is an invalid character(s) in the string. &lt;br /&gt;\n            [NoSuchAtom][chemsynthcalc.chem_errors.NoSuchAtom] if there is an invalid atom(s) in the string. &lt;br /&gt;\n            [BracketsNotPaired][chemsynthcalc.chem_errors.BracketsNotPaired] if the brackets are not in pairs. &lt;br /&gt;\n            [MoreThanOneAdduct][chemsynthcalc.chem_errors.MoreThanOneAdduct] if there are more than 1 adduct symbols in the string. &lt;br /&gt;\n\n        Returns:\n            True if all the checks are OK\n        \"\"\"\n        if self._check_empty_formula():\n            raise EmptyFormula\n        elif self._invalid_charachers():\n            raise InvalidCharacter(\n                f\"Invalid character(s) {self._invalid_charachers()} in the formula {self.formula}\"\n            )\n        elif self._invalid_atoms():\n            raise NoSuchAtom(\n                f\"The formula {self.formula} contains atom {self._invalid_atoms()} which is not in the periodic table\"\n            )\n        elif not self._bracket_balance():\n            raise BracketsNotPaired(\n                f\"The brackets {self.opener_brackets} {self.closer_brackets} are not balanced the formula {self.formula}!\"\n            )\n        elif self._num_of_adducts() &gt; 1:\n            raise MoreThanOneAdduct(\n                f\"More than one adduct {self.adduct_symbols} in the formula {self.formula}\"\n            )\n        return True\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator._check_empty_formula","title":"<code>_check_empty_formula()</code>","text":"<p>Checks if formula is an empty string.</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def _check_empty_formula(self) -&gt; bool:\n    \"\"\"\n    Checks if formula is an empty string.\n    \"\"\"\n    return self.formula == \"\"\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator._invalid_charachers","title":"<code>_invalid_charachers()</code>","text":"<p>Checks if formula contains invalid characters.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of invalid characters</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def _invalid_charachers(self) -&gt; list[str]:\n    \"\"\"\n    Checks if formula contains invalid characters.\n\n    Returns:\n        List of invalid characters\n    \"\"\"\n    return re.compile(self.allowed_symbols).findall(self.formula)\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator._invalid_atoms","title":"<code>_invalid_atoms()</code>","text":"<p>Checks whether the formula contains atoms that are not in the periodic system.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of invalid atoms</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def _invalid_atoms(self) -&gt; list[str]:\n    \"\"\"\n    Checks whether the formula contains atoms that\n    are not in the periodic system.\n\n    Returns:\n        List of invalid atoms\n    \"\"\"\n    atoms_list: list[str] = re.findall(self.atom_regex, self.formula)\n    invalid: list[str] = []\n    new_string: str = self.formula\n    # a trick to get Cl first of C in cases like CCl4\n    atoms_list = sorted(list(set(atoms_list)), key=len, reverse=True)\n    for atom in atoms_list:\n        if atom not in PeriodicTable().atoms:\n            invalid.append(atom)\n        new_string = new_string.replace(atom, \"\")\n    found_leftovers: list[str] = re.findall(r\"[a-z]\", new_string)\n    invalid.extend(found_leftovers)\n    return invalid\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator._bracket_balance","title":"<code>_bracket_balance()</code>","text":"<p>Checks whether all of the brackets come in pairs.</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def _bracket_balance(self) -&gt; bool:\n    \"\"\"\n    Checks whether all of the brackets come in pairs.\n    \"\"\"\n    c: Counter[str] = Counter(self.formula)\n    for i in range(len(self.opener_brackets)):\n        if c[self.opener_brackets[i]] != c[self.closer_brackets[i]]:\n            return False\n    return True\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator._num_of_adducts","title":"<code>_num_of_adducts()</code>","text":"<p>Counts a number of adduct symbols (listed in Formula base class).</p> <p>Returns:</p> Type Description <code>int</code> <p>A number of adduct symbols</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def _num_of_adducts(self) -&gt; int:\n    \"\"\"\n    Counts a number of adduct symbols\n    (listed in [Formula base class][chemsynthcalc.formula.Formula]).\n\n    Returns:\n        A number of adduct symbols\n    \"\"\"\n    c: Counter[str] = Counter(self.formula)\n    i: int = 0\n    for adduct in self.adduct_symbols:\n        i += c[adduct]\n    return i\n</code></pre>"},{"location":"API/#chemsynthcalc.formula_validator.FormulaValidator.validate_formula","title":"<code>validate_formula()</code>","text":"<p>Validation of the formula string. Calls the private methods of this class in order.</p> Raise <p>EmptyFormula if the formula is an empty string.  InvalidCharacter if there is an invalid character(s) in the string.  NoSuchAtom if there is an invalid atom(s) in the string.  BracketsNotPaired if the brackets are not in pairs.  MoreThanOneAdduct if there are more than 1 adduct symbols in the string. </p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all the checks are OK</p> Source code in <code>src/chemsynthcalc/formula_validator.py</code> <pre><code>def validate_formula(self) -&gt; bool:\n    \"\"\"\n    Validation of the formula string.\n    Calls the private methods of this class in order.\n\n    Raise:\n        [EmptyFormula][chemsynthcalc.chem_errors.EmptyFormula] if the formula is an empty string. &lt;br /&gt;\n        [InvalidCharacter][chemsynthcalc.chem_errors.InvalidCharacter] if there is an invalid character(s) in the string. &lt;br /&gt;\n        [NoSuchAtom][chemsynthcalc.chem_errors.NoSuchAtom] if there is an invalid atom(s) in the string. &lt;br /&gt;\n        [BracketsNotPaired][chemsynthcalc.chem_errors.BracketsNotPaired] if the brackets are not in pairs. &lt;br /&gt;\n        [MoreThanOneAdduct][chemsynthcalc.chem_errors.MoreThanOneAdduct] if there are more than 1 adduct symbols in the string. &lt;br /&gt;\n\n    Returns:\n        True if all the checks are OK\n    \"\"\"\n    if self._check_empty_formula():\n        raise EmptyFormula\n    elif self._invalid_charachers():\n        raise InvalidCharacter(\n            f\"Invalid character(s) {self._invalid_charachers()} in the formula {self.formula}\"\n        )\n    elif self._invalid_atoms():\n        raise NoSuchAtom(\n            f\"The formula {self.formula} contains atom {self._invalid_atoms()} which is not in the periodic table\"\n        )\n    elif not self._bracket_balance():\n        raise BracketsNotPaired(\n            f\"The brackets {self.opener_brackets} {self.closer_brackets} are not balanced the formula {self.formula}!\"\n        )\n    elif self._num_of_adducts() &gt; 1:\n        raise MoreThanOneAdduct(\n            f\"More than one adduct {self.adduct_symbols} in the formula {self.formula}\"\n        )\n    return True\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass","title":"<code>molar_mass</code>","text":""},{"location":"API/#chemsynthcalc.molar_mass.Oxide","title":"<code>Oxide</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A named tuple to represent oxide properties: a first atom (usually metal), full oxide compound string and mass percent of the first atom in the initial formula.</p> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>class Oxide(NamedTuple):\n    \"\"\"\n    A named tuple to represent oxide properties: a first atom\n    (usually metal), full oxide compound string and mass percent\n    of the first atom in the initial formula.\n    \"\"\"\n\n    atom: str\n    label: str\n    mass_percent: float\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation","title":"<code>MolarMassCalculation</code>","text":"<p>Class for the calculation of molar masses and percentages of a compound.</p> <p>Compound should be parsed by ChemicalFormulaParser first.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_formula</code> <code>dict</code> <p>Formula parsed by ChemicalFormulaParser</p> required <p>Attributes:</p> Name Type Description <code>p_table</code> <code>dict[str, Atom]</code> <p>Periodic table of elements</p> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>class MolarMassCalculation:\n    \"\"\"\n    Class for the calculation of molar masses and percentages of a compound.\n\n    Compound should be parsed by\n    [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser] first.\n\n    Parameters:\n        parsed_formula (dict): Formula parsed by [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser]\n\n    Attributes:\n        p_table (dict[str, Atom]): Periodic table of elements\n    \"\"\"\n\n    def __init__(self, parsed_formula: dict[str, float]) -&gt; None:\n        self.parsed_formula: dict[str, float] = parsed_formula\n        self.p_table = PeriodicTable().p_table\n\n    def _calculate_atomic_masses(self) -&gt; list[float]:\n        \"\"\"\n        Calculation of the molar masses of\n        all atoms in a parsed formula.\n\n        Returns:\n            List of atomic masses multiplied by the number of corresponding atoms\n        \"\"\"\n        masses: list[float] = []\n        for atom, weight in self.parsed_formula.items():\n            atom_mass: float = self.p_table[atom].atomic_weight\n            masses.append(atom_mass * weight)\n        return masses\n\n    def calculate_molar_mass(self) -&gt; float:\n        \"\"\"\n        Calculation of the molar mass of compound from\n        the atomic masses of atoms in a parsed formula.\n\n        Returns:\n            Molar mass (in g/mol)\n\n        Examples:\n            &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_molar_mass()\n            18.015\n            &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_molar_mass()\n            46.069\n        \"\"\"\n        return sum(self._calculate_atomic_masses())\n\n    def calculate_mass_percent(self) -&gt; dict[str, float]:\n        \"\"\"\n        Calculation of mass percents of atoms in parsed formula.\n\n        Returns:\n            Mass percentages of atoms in the formula\n\n        Examples:\n            &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_mass_percent()\n            {'H': 11.19067443796836, 'O': 88.80932556203163}\n            &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_mass_percent()\n            {'C': 52.14352384466777, 'H': 13.12813388612733, 'O': 34.72834226920489}\n        \"\"\"\n        atomic_masses: list[float] = self._calculate_atomic_masses()\n        molar_mass: float = self.calculate_molar_mass()\n        percents: list[float] = [atomic / molar_mass * 100 for atomic in atomic_masses]\n        return dict(zip(self.parsed_formula.keys(), percents))\n\n    def calculate_atomic_percent(self) -&gt; dict[str, float]:\n        \"\"\"\n        Calculation of atomic percents of atoms in the parsed formula.\n\n        Returns:\n            Atomic percentages of atoms in the formula\n\n        Examples:\n            &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_atomic_percent()\n            {'H': 66.66666666666666, 'O': 33.33333333333333\n            &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_atomic_percent()\n            {'C': 22.22222222222222, 'H': 66.66666666666666, 'O': 11.11111111111111}\n        \"\"\"\n        values: list[float] = list(self.parsed_formula.values())\n        atomic: list[float] = [value / sum(values) * 100 for value in values]\n        return dict(zip(self.parsed_formula.keys(), atomic))\n\n    def _custom_oxides_input(self, *args: str) -&gt; list[Oxide]:\n        \"\"\"\n        Checks if passed non-default oxide formulas can be applied to any\n        atom in parsed formula. If so, replaces it with said non-default oxide.\n        If not, the default oxide is chosen.\n\n        Parameters:\n            *args (tuple[str, ...]): An arbitrary number of non-default oxide formulas\n\n        Returns:\n            A list of Oxide objects\n\n        Raise:\n            ValueError if compound is not binary or second element is not oxygen\n        \"\"\"\n        first_atoms: list[str] = []\n        for c_oxide in args:\n            parsed_oxide = list(ChemicalFormulaParser(c_oxide).parse_formula().keys())\n\n            if len(parsed_oxide) &gt; 2:\n                raise ValueError(\"Only binary compounds can be considered as input\")\n\n            elif parsed_oxide[1] != \"O\":\n                raise ValueError(\"Only oxides can be considered as input\")\n\n            first_atoms.append(parsed_oxide[0])\n\n        custom_oxides = dict(zip(first_atoms, args))\n        mass_percents: list[float] = list(self.calculate_mass_percent().values())\n        oxides: list[Oxide] = []\n        for i, atom in enumerate(self.parsed_formula.keys()):\n            if atom != \"O\":\n                if atom in custom_oxides.keys():\n                    label = custom_oxides[atom]\n                else:\n                    label = self.p_table[atom].default_oxide\n                oxides.append(Oxide(atom, label, mass_percents[i]))\n\n        return oxides\n\n    def calculate_oxide_percent(self, *args: str) -&gt; dict[str, float]:\n        \"\"\"\n        Calculation of oxide percents in parsed formula.\n\n        Calculation of oxide percents in parsed formula from the types of oxide\n        declared in the periodic table file. This type of data\n        is mostly used in XRF spectrometry and mineralogy. The oxide\n        percents are calculated by finding the [convertion factor between element\n        and its respective oxide](https://www.geol.umd.edu/~piccoli/probe/molweight.html)\n        and normalizing the total sum to 100%. One can change the oxide type\n        for certain elements in the [periodic_table.py][chemsynthcalc.periodic_table] file. Theoretically, this function\n        should work for other types of binary compound (sulfides, fluorides etc.)\n        or even salts, however, modification of this function is required\n        (for instance, in case of binary compound, removing X atom\n        from the list of future compounds should have X as an argument of this function).\n\n        Parameters:\n            *args (tuple[str, ...]): An arbitrary number of non-default oxide formulas\n\n        Returns:\n            Percentages of oxides in the formula\n\n        Examples:\n            &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_oxide_percent()\n            {'CO2': 61.9570190690046, 'H2O': 38.04298093099541}\n            &gt;&gt;&gt; MolarMassCalculation({'Ba':1, 'Ti':1, 'O':3}).calculate_oxide_percent()\n            {'BaO': 65.7516917244869, 'TiO2': 34.24830827551309}\n        \"\"\"\n        oxides: list[Oxide] = self._custom_oxides_input(*args)\n\n        oxide_percents: list[float] = []\n\n        for oxide in oxides:\n            parsed_oxide: dict[str, float] = ChemicalFormulaParser(\n                oxide.label\n            ).parse_formula()\n            oxide_mass: float = MolarMassCalculation(\n                parsed_oxide\n            ).calculate_molar_mass()\n            atomic_oxide_coef: float = parsed_oxide[oxide.atom]\n            atomic_mass: float = self.p_table[oxide.atom].atomic_weight\n            conversion_factor: float = oxide_mass / atomic_mass / atomic_oxide_coef\n            oxide_percents.append(oxide.mass_percent * conversion_factor)\n\n        normalized_oxide_percents: list[float] = [\n            x / sum(oxide_percents) * 100 for x in oxide_percents\n        ]\n        oxide_labels: list[str] = [oxide.label for oxide in oxides]\n\n        return dict(zip(oxide_labels, normalized_oxide_percents))\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation._calculate_atomic_masses","title":"<code>_calculate_atomic_masses()</code>","text":"<p>Calculation of the molar masses of all atoms in a parsed formula.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>List of atomic masses multiplied by the number of corresponding atoms</p> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def _calculate_atomic_masses(self) -&gt; list[float]:\n    \"\"\"\n    Calculation of the molar masses of\n    all atoms in a parsed formula.\n\n    Returns:\n        List of atomic masses multiplied by the number of corresponding atoms\n    \"\"\"\n    masses: list[float] = []\n    for atom, weight in self.parsed_formula.items():\n        atom_mass: float = self.p_table[atom].atomic_weight\n        masses.append(atom_mass * weight)\n    return masses\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation.calculate_molar_mass","title":"<code>calculate_molar_mass()</code>","text":"<p>Calculation of the molar mass of compound from the atomic masses of atoms in a parsed formula.</p> <p>Returns:</p> Type Description <code>float</code> <p>Molar mass (in g/mol)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_molar_mass()\n18.015\n&gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_molar_mass()\n46.069\n</code></pre> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def calculate_molar_mass(self) -&gt; float:\n    \"\"\"\n    Calculation of the molar mass of compound from\n    the atomic masses of atoms in a parsed formula.\n\n    Returns:\n        Molar mass (in g/mol)\n\n    Examples:\n        &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_molar_mass()\n        18.015\n        &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_molar_mass()\n        46.069\n    \"\"\"\n    return sum(self._calculate_atomic_masses())\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation.calculate_mass_percent","title":"<code>calculate_mass_percent()</code>","text":"<p>Calculation of mass percents of atoms in parsed formula.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Mass percentages of atoms in the formula</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_mass_percent()\n{'H': 11.19067443796836, 'O': 88.80932556203163}\n&gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_mass_percent()\n{'C': 52.14352384466777, 'H': 13.12813388612733, 'O': 34.72834226920489}\n</code></pre> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def calculate_mass_percent(self) -&gt; dict[str, float]:\n    \"\"\"\n    Calculation of mass percents of atoms in parsed formula.\n\n    Returns:\n        Mass percentages of atoms in the formula\n\n    Examples:\n        &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_mass_percent()\n        {'H': 11.19067443796836, 'O': 88.80932556203163}\n        &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_mass_percent()\n        {'C': 52.14352384466777, 'H': 13.12813388612733, 'O': 34.72834226920489}\n    \"\"\"\n    atomic_masses: list[float] = self._calculate_atomic_masses()\n    molar_mass: float = self.calculate_molar_mass()\n    percents: list[float] = [atomic / molar_mass * 100 for atomic in atomic_masses]\n    return dict(zip(self.parsed_formula.keys(), percents))\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation.calculate_atomic_percent","title":"<code>calculate_atomic_percent()</code>","text":"<p>Calculation of atomic percents of atoms in the parsed formula.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Atomic percentages of atoms in the formula</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_atomic_percent()\n{'H': 66.66666666666666, 'O': 33.33333333333333\n&gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_atomic_percent()\n{'C': 22.22222222222222, 'H': 66.66666666666666, 'O': 11.11111111111111}\n</code></pre> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def calculate_atomic_percent(self) -&gt; dict[str, float]:\n    \"\"\"\n    Calculation of atomic percents of atoms in the parsed formula.\n\n    Returns:\n        Atomic percentages of atoms in the formula\n\n    Examples:\n        &gt;&gt;&gt; MolarMassCalculation({'H':2, 'O':1}).calculate_atomic_percent()\n        {'H': 66.66666666666666, 'O': 33.33333333333333\n        &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_atomic_percent()\n        {'C': 22.22222222222222, 'H': 66.66666666666666, 'O': 11.11111111111111}\n    \"\"\"\n    values: list[float] = list(self.parsed_formula.values())\n    atomic: list[float] = [value / sum(values) * 100 for value in values]\n    return dict(zip(self.parsed_formula.keys(), atomic))\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation._custom_oxides_input","title":"<code>_custom_oxides_input(*args)</code>","text":"<p>Checks if passed non-default oxide formulas can be applied to any atom in parsed formula. If so, replaces it with said non-default oxide. If not, the default oxide is chosen.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>tuple[str, ...]</code> <p>An arbitrary number of non-default oxide formulas</p> <code>()</code> <p>Returns:</p> Type Description <code>list[Oxide]</code> <p>A list of Oxide objects</p> Raise <p>ValueError if compound is not binary or second element is not oxygen</p> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def _custom_oxides_input(self, *args: str) -&gt; list[Oxide]:\n    \"\"\"\n    Checks if passed non-default oxide formulas can be applied to any\n    atom in parsed formula. If so, replaces it with said non-default oxide.\n    If not, the default oxide is chosen.\n\n    Parameters:\n        *args (tuple[str, ...]): An arbitrary number of non-default oxide formulas\n\n    Returns:\n        A list of Oxide objects\n\n    Raise:\n        ValueError if compound is not binary or second element is not oxygen\n    \"\"\"\n    first_atoms: list[str] = []\n    for c_oxide in args:\n        parsed_oxide = list(ChemicalFormulaParser(c_oxide).parse_formula().keys())\n\n        if len(parsed_oxide) &gt; 2:\n            raise ValueError(\"Only binary compounds can be considered as input\")\n\n        elif parsed_oxide[1] != \"O\":\n            raise ValueError(\"Only oxides can be considered as input\")\n\n        first_atoms.append(parsed_oxide[0])\n\n    custom_oxides = dict(zip(first_atoms, args))\n    mass_percents: list[float] = list(self.calculate_mass_percent().values())\n    oxides: list[Oxide] = []\n    for i, atom in enumerate(self.parsed_formula.keys()):\n        if atom != \"O\":\n            if atom in custom_oxides.keys():\n                label = custom_oxides[atom]\n            else:\n                label = self.p_table[atom].default_oxide\n            oxides.append(Oxide(atom, label, mass_percents[i]))\n\n    return oxides\n</code></pre>"},{"location":"API/#chemsynthcalc.molar_mass.MolarMassCalculation.calculate_oxide_percent","title":"<code>calculate_oxide_percent(*args)</code>","text":"<p>Calculation of oxide percents in parsed formula.</p> <p>Calculation of oxide percents in parsed formula from the types of oxide declared in the periodic table file. This type of data is mostly used in XRF spectrometry and mineralogy. The oxide percents are calculated by finding the convertion factor between element and its respective oxide and normalizing the total sum to 100%. One can change the oxide type for certain elements in the periodic_table.py file. Theoretically, this function should work for other types of binary compound (sulfides, fluorides etc.) or even salts, however, modification of this function is required (for instance, in case of binary compound, removing X atom from the list of future compounds should have X as an argument of this function).</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>tuple[str, ...]</code> <p>An arbitrary number of non-default oxide formulas</p> <code>()</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Percentages of oxides in the formula</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_oxide_percent()\n{'CO2': 61.9570190690046, 'H2O': 38.04298093099541}\n&gt;&gt;&gt; MolarMassCalculation({'Ba':1, 'Ti':1, 'O':3}).calculate_oxide_percent()\n{'BaO': 65.7516917244869, 'TiO2': 34.24830827551309}\n</code></pre> Source code in <code>src/chemsynthcalc/molar_mass.py</code> <pre><code>def calculate_oxide_percent(self, *args: str) -&gt; dict[str, float]:\n    \"\"\"\n    Calculation of oxide percents in parsed formula.\n\n    Calculation of oxide percents in parsed formula from the types of oxide\n    declared in the periodic table file. This type of data\n    is mostly used in XRF spectrometry and mineralogy. The oxide\n    percents are calculated by finding the [convertion factor between element\n    and its respective oxide](https://www.geol.umd.edu/~piccoli/probe/molweight.html)\n    and normalizing the total sum to 100%. One can change the oxide type\n    for certain elements in the [periodic_table.py][chemsynthcalc.periodic_table] file. Theoretically, this function\n    should work for other types of binary compound (sulfides, fluorides etc.)\n    or even salts, however, modification of this function is required\n    (for instance, in case of binary compound, removing X atom\n    from the list of future compounds should have X as an argument of this function).\n\n    Parameters:\n        *args (tuple[str, ...]): An arbitrary number of non-default oxide formulas\n\n    Returns:\n        Percentages of oxides in the formula\n\n    Examples:\n        &gt;&gt;&gt; MolarMassCalculation({'C':2, 'H':6, 'O':1}).calculate_oxide_percent()\n        {'CO2': 61.9570190690046, 'H2O': 38.04298093099541}\n        &gt;&gt;&gt; MolarMassCalculation({'Ba':1, 'Ti':1, 'O':3}).calculate_oxide_percent()\n        {'BaO': 65.7516917244869, 'TiO2': 34.24830827551309}\n    \"\"\"\n    oxides: list[Oxide] = self._custom_oxides_input(*args)\n\n    oxide_percents: list[float] = []\n\n    for oxide in oxides:\n        parsed_oxide: dict[str, float] = ChemicalFormulaParser(\n            oxide.label\n        ).parse_formula()\n        oxide_mass: float = MolarMassCalculation(\n            parsed_oxide\n        ).calculate_molar_mass()\n        atomic_oxide_coef: float = parsed_oxide[oxide.atom]\n        atomic_mass: float = self.p_table[oxide.atom].atomic_weight\n        conversion_factor: float = oxide_mass / atomic_mass / atomic_oxide_coef\n        oxide_percents.append(oxide.mass_percent * conversion_factor)\n\n    normalized_oxide_percents: list[float] = [\n        x / sum(oxide_percents) * 100 for x in oxide_percents\n    ]\n    oxide_labels: list[str] = [oxide.label for oxide in oxides]\n\n    return dict(zip(oxide_labels, normalized_oxide_percents))\n</code></pre>"},{"location":"API/#chemsynthcalc.periodic_table","title":"<code>periodic_table</code>","text":""},{"location":"API/#chemsynthcalc.periodic_table.Atom","title":"<code>Atom</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Named tuple for representing atomic properties: atomic weight and type of oxide that will be used by default.</p> Source code in <code>src/chemsynthcalc/periodic_table.py</code> <pre><code>class Atom(NamedTuple):\n    \"\"\"\n    Named tuple for representing atomic properties:\n    atomic weight and type of oxide that will be used by default.\n    \"\"\"\n\n    atomic_weight: float\n    default_oxide: str\n</code></pre>"},{"location":"API/#chemsynthcalc.periodic_table.PeriodicTable","title":"<code>PeriodicTable</code>","text":"<p>Periodic table of elements in the form of \"Atom symbol\": Atom NamedTuple. The standard atomic weights are taken from IUPAC.</p> Source code in <code>src/chemsynthcalc/periodic_table.py</code> <pre><code>class PeriodicTable:\n    \"\"\"\n    Periodic table of elements in the form of \"Atom symbol\": Atom NamedTuple.\n    The standard atomic weights are taken from [IUPAC](https://iupac.qmul.ac.uk/AtWt/).\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.p_table: dict[str, Atom] = {\n            \"H\": Atom(1.008, \"H2O\"),\n            \"He\": Atom(4.002602, \"He\"),\n            \"Li\": Atom(6.94, \"Li2O\"),\n            \"Be\": Atom(9.0121831, \"BeO\"),\n            \"B\": Atom(10.81, \"B2O3\"),\n            \"C\": Atom(12.011, \"CO2\"),\n            \"N\": Atom(14.007, \"NO2\"),\n            \"O\": Atom(15.999, \"O\"),\n            \"F\": Atom(18.998403162, \"F2O\"),\n            \"Ne\": Atom(20.1797, \"Ne\"),\n            \"Na\": Atom(22.98976928, \"Na2O\"),\n            \"Mg\": Atom(24.305, \"MgO\"),\n            \"Al\": Atom(26.9815384, \"Al2O3\"),\n            \"Si\": Atom(28.085, \"SiO2\"),\n            \"P\": Atom(30.973761998, \"P2O3\"),\n            \"S\": Atom(32.06, \"SO3\"),\n            \"Cl\": Atom(35.45, \"ClO2\"),\n            \"Ar\": Atom(39.95, \"Ar\"),\n            \"K\": Atom(39.098, \"K2O\"),\n            \"Ca\": Atom(40.078, \"CaO\"),\n            \"Sc\": Atom(44.955907, \"Sc2O3\"),\n            \"Ti\": Atom(47.867, \"TiO2\"),\n            \"V\": Atom(50.9415, \"V2O5\"),\n            \"Cr\": Atom(51.9961, \"Cr2O3\"),\n            \"Mn\": Atom(54.938043, \"MnO2\"),\n            \"Fe\": Atom(55.845, \"Fe2O3\"),\n            \"Co\": Atom(58.933194, \"Co2O3\"),\n            \"Ni\": Atom(58.6934, \"NiO\"),\n            \"Cu\": Atom(63.546, \"Cu2O\"),\n            \"Zn\": Atom(65.38, \"ZnO\"),\n            \"Ga\": Atom(69.723, \"Ga2O3\"),\n            \"Ge\": Atom(72.63, \"GeO2\"),\n            \"As\": Atom(74.921595, \"As2O3\"),\n            \"Se\": Atom(78.971, \"Se3O4\"),\n            \"Br\": Atom(79.904, \"BrO2\"),\n            \"Kr\": Atom(83.798, \"Kr\"),\n            \"Rb\": Atom(85.4678, \"Rb2O\"),\n            \"Sr\": Atom(87.62, \"SrO\"),\n            \"Y\": Atom(88.905838, \"Y2O3\"),\n            \"Zr\": Atom(91.222, \"ZrO2\"),\n            \"Nb\": Atom(92.90637, \"Nb2O5\"),\n            \"Mo\": Atom(95.95, \"MoO3\"),\n            \"Tc\": Atom(97, \"TcO2\"),\n            \"Ru\": Atom(101.07, \"RuO2\"),\n            \"Rh\": Atom(102.90549, \"Rh2O3\"),\n            \"Pd\": Atom(106.42, \"PdO\"),\n            \"Ag\": Atom(107.8682, \"Ag2O\"),\n            \"Cd\": Atom(112.414, \"CdO\"),\n            \"In\": Atom(114.818, \"In2O3\"),\n            \"Sn\": Atom(118.71, \"SnO2\"),\n            \"Sb\": Atom(121.76, \"Sb2O3\"),\n            \"Te\": Atom(127.6, \"TeO3\"),\n            \"I\": Atom(126.90447, \"I2O5\"),\n            \"Xe\": Atom(131.29, \"Xe\"),\n            \"Cs\": Atom(132.90545196, \"Cs2O\"),\n            \"Ba\": Atom(137.327, \"BaO\"),\n            \"La\": Atom(138.90547, \"La2O3\"),\n            \"Ce\": Atom(140.116, \"CeO2\"),\n            \"Pr\": Atom(140.90766, \"Pr2O3\"),\n            \"Nd\": Atom(144.242, \"Nd2O3\"),\n            \"Pm\": Atom(145, \"Pm2O3\"),\n            \"Sm\": Atom(150.36, \"Sm2O3\"),\n            \"Eu\": Atom(151.964, \"Eu2O3\"),\n            \"Gd\": Atom(157.249, \"Gd2O3\"),\n            \"Tb\": Atom(158.925354, \"Tb2O3\"),\n            \"Dy\": Atom(162.5, \"Dy2O3\"),\n            \"Ho\": Atom(164.930329, \"Ho2O3\"),\n            \"Er\": Atom(167.259, \"Er2O3\"),\n            \"Tm\": Atom(168.934219, \"Tm2O3\"),\n            \"Yb\": Atom(173.045, \"Yb2O3\"),\n            \"Lu\": Atom(174.96669, \"Lu2O3\"),\n            \"Hf\": Atom(178.486, \"HfO2\"),\n            \"Ta\": Atom(180.94788, \"Ta2O5\"),\n            \"W\": Atom(183.84, \"WO3\"),\n            \"Re\": Atom(186.207, \"Re2O7\"),\n            \"Os\": Atom(190.23, \"OsO3\"),\n            \"Ir\": Atom(192.217, \"Ir2O3\"),\n            \"Pt\": Atom(195.084, \"PtO\"),\n            \"Au\": Atom(196.966570, \"Au2O3\"),\n            \"Hg\": Atom(200.592, \"HgO2\"),\n            \"Tl\": Atom(204.38, \"Tl2O\"),\n            \"Pb\": Atom(207.2, \"PbO2\"),\n            \"Bi\": Atom(208.98040, \"Bi2O3\"),\n            \"Po\": Atom(209, \"PoO2\"),\n            \"At\": Atom(210, \"At2O\"),\n            \"Rn\": Atom(222, \"Rn\"),\n            \"Fr\": Atom(223, \"Fr2O\"),\n            \"Ra\": Atom(226, \"RaO\"),\n            \"Ac\": Atom(227, \"Ac2O3\"),\n            \"Th\": Atom(232.0377, \"ThO2\"),\n            \"Pa\": Atom(231.03588, \"Pa2O5\"),\n            \"U\": Atom(238.02891, \"UO2\"),\n            \"Np\": Atom(237, \"NpO2\"),\n            \"Pu\": Atom(244, \"PuO2\"),\n            \"Am\": Atom(243, \"AmO2\"),\n            \"Cm\": Atom(247, \"Cm2O3\"),\n            \"Bk\": Atom(247, \"BkO2\"),\n            \"Cf\": Atom(251, \"Cf2O3\"),\n            \"Es\": Atom(252, \"Es2O3\"),\n            \"Fm\": Atom(257, \"Fm2O3\"),\n            \"Md\": Atom(258, \"Md2O3\"),\n            \"No\": Atom(259, \"No2O3\"),\n            \"Lr\": Atom(262, \"Lr2O3\"),\n            \"Rf\": Atom(267, \"RfO2\"),\n            \"Db\": Atom(270, \"Db2O5\"),\n            \"Sg\": Atom(269, \"SgO4\"),\n            \"Bh\": Atom(270, \"Bh2O7\"),\n            \"Hs\": Atom(270, \"HsO3\"),\n            \"Mt\": Atom(278, \"Mt2O3\"),\n            \"Ds\": Atom(281, \"DsO2\"),\n            \"Rg\": Atom(281, \"RgO\"),\n            \"Cn\": Atom(285, \"Cn2O3\"),\n            \"Nh\": Atom(286, \"NhO2\"),\n            \"Fl\": Atom(289, \"FlO2\"),\n            \"Mc\": Atom(289, \"Mc2O5\"),\n            \"Lv\": Atom(293, \"LvO3\"),\n            \"Ts\": Atom(293, \"Ts2O7\"),\n            \"Og\": Atom(294, \"Og\"),\n        }\n        self.atoms: set[str] = set(self.p_table.keys())\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction","title":"<code>reaction</code>","text":""},{"location":"API/#chemsynthcalc.reaction.Reaction","title":"<code>Reaction</code>","text":"<p>A base class for ReactionDecomposer and ReactionValidator containing regexes and symbols.</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>str</code> <p>Reaction string</p> required <p>Attributes:</p> Name Type Description <code>allowed_symbols</code> <code>str</code> <p>Regex of all symbols allowed in a reaction string</p> <code>possible_reaction_separators</code> <code>list[str]</code> <p>List of all allowed reaction separators (left and right part separator)</p> <code>reactant_separator</code> <code>str</code> <p>Only one possible reactant separator (\"+\")</p> Source code in <code>src/chemsynthcalc/reaction.py</code> <pre><code>class Reaction:\n    \"\"\"\n    A base class for\n    [ReactionDecomposer][chemsynthcalc.reaction_decomposer.ReactionDecomposer] and\n    [ReactionValidator][chemsynthcalc.reaction_validator.ReactionValidator]\n    containing regexes and symbols.\n\n    Parameters:\n        reaction (str): Reaction string\n\n    Attributes:\n        allowed_symbols (str): Regex of all symbols allowed in a reaction string\n        possible_reaction_separators (list[str]): List of all allowed reaction separators (left and right part separator)\n        reactant_separator (str): Only one possible reactant separator (\"+\")\n    \"\"\"\n\n    def __init__(self, reaction: str) -&gt; None:\n        self.allowed_symbols: str = r\"[^a-zA-Z0-9.({[)}\\]*\u00b7\u2022=&lt;\\-&gt;\u2192\u21c4+ ]\"\n        self.possible_reaction_separators: list[str] = [\n            \"==\",\n            \"=\",\n            \"&lt;-&gt;\",\n            \"-&gt;\",\n            \"&lt;&gt;\",\n            \"&gt;\",\n            \"\u2192\",\n            \"\u21c4\",\n        ]\n        self.reactant_separator: str = \"+\"\n\n        self.reaction = reaction\n\n    def extract_separator(self) -&gt; str:\n        \"\"\"\n        Extract one of possible reaction separator from\n        the reaction string.\n\n        Returns:\n            Separator string if separator is found, empty string if not\n        \"\"\"\n        for separator in self.possible_reaction_separators:\n            if self.reaction.find(separator) != -1:\n                if (\n                    self.reaction.split(separator)[1] != \"\"\n                    and self.reaction.split(separator)[0] != \"\"\n                ):\n                    return separator\n        return \"\"\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction.Reaction.extract_separator","title":"<code>extract_separator()</code>","text":"<p>Extract one of possible reaction separator from the reaction string.</p> <p>Returns:</p> Type Description <code>str</code> <p>Separator string if separator is found, empty string if not</p> Source code in <code>src/chemsynthcalc/reaction.py</code> <pre><code>def extract_separator(self) -&gt; str:\n    \"\"\"\n    Extract one of possible reaction separator from\n    the reaction string.\n\n    Returns:\n        Separator string if separator is found, empty string if not\n    \"\"\"\n    for separator in self.possible_reaction_separators:\n        if self.reaction.find(separator) != -1:\n            if (\n                self.reaction.split(separator)[1] != \"\"\n                and self.reaction.split(separator)[0] != \"\"\n            ):\n                return separator\n    return \"\"\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_decomposer","title":"<code>reaction_decomposer</code>","text":""},{"location":"API/#chemsynthcalc.reaction_decomposer.ReactionDecomposer","title":"<code>ReactionDecomposer</code>","text":"<p>               Bases: <code>Reaction</code></p> <p>Decomposition of chemical reaction string and extraction of reaction separator, reactants, products and initial coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>str</code> <p>A reaction string</p> required <p>Attributes:</p> Name Type Description <code>separator</code> <code>str</code> <p>A reactants - products separator (usually \"+\")</p> <code>initial_coefficients</code> <code>list[float]</code> <p>A list of coefficients striped from the formulas</p> <code>reactants</code> <code>list[str]</code> <p>A list of compound from letf part of the reaction equation</p> <code>products</code> <code>list[str]</code> <p>A list of compound from right part of the reaction equation</p> <code>compounds</code> <code>list[str]</code> <p>reactants + products</p> Source code in <code>src/chemsynthcalc/reaction_decomposer.py</code> <pre><code>class ReactionDecomposer(Reaction):\n    \"\"\"\n    Decomposition of chemical reaction string and extraction of\n    reaction separator, reactants, products and initial coefficients.\n\n    Arguments:\n        reaction (str): A reaction string\n\n    Attributes:\n        separator (str): A reactants - products separator (usually \"+\")\n        initial_coefficients (list[float]): A list of coefficients striped from the formulas\n        reactants (list[str]): A list of compound from letf part of the reaction equation\n        products (list[str]): A list of compound from right part of the reaction equation\n        compounds (list[str]): reactants + products\n    \"\"\"\n\n    def __init__(self, reaction: str) -&gt; None:\n        super().__init__(reaction)\n\n        self.separator: str = self.extract_separator()\n\n        self._initial_reactants: list[str] = self.reaction.split(self.separator)[\n            0\n        ].split(self.reactant_separator)\n        self._initial_products: list[str] = self.reaction.split(self.separator)[\n            1\n        ].split(self.reactant_separator)\n        self._splitted_compounds: list[tuple[float, str]] = [\n            self.split_coefficient_from_formula(formula)\n            for formula in self._initial_reactants + self._initial_products\n        ]\n\n        self.initial_coefficients: list[float] = [\n            atom[0] for atom in self._splitted_compounds\n        ]\n        self.compounds: list[str] = [atom[1] for atom in self._splitted_compounds]\n        self.reactants: list[str] = self.compounds[: len(self._initial_reactants)]\n        self.products: list[str] = self.compounds[len(self._initial_reactants) :]\n\n    def __str__(self) -&gt; str:\n        return f\"separator: {self.separator}; reactants: {self.reactants}; products: {self.products}\"\n\n    def __repr__(self) -&gt; str:\n        return f\"ReactionDecomposer({self.reaction})\"\n\n    def split_coefficient_from_formula(self, formula: str) -&gt; tuple[float, str]:\n        \"\"\"\n        Split the coefficient (int or float) from string containing formula and coef.\n\n        Parameters:\n            formula (str): Formula string\n\n        Returns:\n            A tuple of (coefficient, formula)\n        \"\"\"\n        if not formula[0].isdigit():\n            return 1.0, formula\n        else:\n            coef: list[str] = []\n            i: int = 0\n            for i, symbol in enumerate(formula):\n                if symbol.isdigit() or symbol == \".\":\n                    coef.append(symbol)\n                else:\n                    break\n            return float(\"\".join(coef)), formula[i:]\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_decomposer.ReactionDecomposer.split_coefficient_from_formula","title":"<code>split_coefficient_from_formula(formula)</code>","text":"<p>Split the coefficient (int or float) from string containing formula and coef.</p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Formula string</p> required <p>Returns:</p> Type Description <code>tuple[float, str]</code> <p>A tuple of (coefficient, formula)</p> Source code in <code>src/chemsynthcalc/reaction_decomposer.py</code> <pre><code>def split_coefficient_from_formula(self, formula: str) -&gt; tuple[float, str]:\n    \"\"\"\n    Split the coefficient (int or float) from string containing formula and coef.\n\n    Parameters:\n        formula (str): Formula string\n\n    Returns:\n        A tuple of (coefficient, formula)\n    \"\"\"\n    if not formula[0].isdigit():\n        return 1.0, formula\n    else:\n        coef: list[str] = []\n        i: int = 0\n        for i, symbol in enumerate(formula):\n            if symbol.isdigit() or symbol == \".\":\n                coef.append(symbol)\n            else:\n                break\n        return float(\"\".join(coef)), formula[i:]\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_matrix","title":"<code>reaction_matrix</code>","text":""},{"location":"API/#chemsynthcalc.reaction_matrix.ChemicalReactionMatrix","title":"<code>ChemicalReactionMatrix</code>","text":"<p>A class to create a dense float matrix from the parsed formulas.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_formulas</code> <code>list[dict[str, float]]</code> <p>A list of formulas parsed by ChemicalFormulaParser</p> required Source code in <code>src/chemsynthcalc/reaction_matrix.py</code> <pre><code>class ChemicalReactionMatrix:\n    \"\"\"\n    A class to create a dense float matrix from the parsed formulas.\n\n    Arguments:\n        parsed_formulas (list[dict[str, float]]): A list of formulas parsed by [ChemicalFormulaParser][chemsynthcalc.formula_parser.ChemicalFormulaParser]\n    \"\"\"\n\n    def __init__(self, parsed_formulas: list[dict[str, float]]) -&gt; None:\n        self._parsed_formulas = parsed_formulas\n        self._merged_dict: dict[str, float] = {\n            k: v for d in self._parsed_formulas for k, v in d.items()\n        }\n        self._elements: list[str] = list(self._merged_dict.keys())\n        self.matrix: npt.NDArray[np.float64] = self.create_reaction_matrix()\n\n    def create_reaction_matrix(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"\n        Creates a 2D NumPy array from nested Python lists.\n        The content of lists are exctracted from parsed dicts.\n\n        Returns:\n            A 2D NumPy array of the reaction matrix\n        \"\"\"\n        matrix: list[list[float]] = []\n        for element in self._elements:\n            row: list[float] = []\n            for compound in self._parsed_formulas:\n                if element in compound.keys():\n                    row.append(compound[element])\n                else:\n                    row.append(0.0)\n            matrix.append(row)\n        return np.array(matrix)\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_matrix.ChemicalReactionMatrix.create_reaction_matrix","title":"<code>create_reaction_matrix()</code>","text":"<p>Creates a 2D NumPy array from nested Python lists. The content of lists are exctracted from parsed dicts.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A 2D NumPy array of the reaction matrix</p> Source code in <code>src/chemsynthcalc/reaction_matrix.py</code> <pre><code>def create_reaction_matrix(self) -&gt; npt.NDArray[np.float64]:\n    \"\"\"\n    Creates a 2D NumPy array from nested Python lists.\n    The content of lists are exctracted from parsed dicts.\n\n    Returns:\n        A 2D NumPy array of the reaction matrix\n    \"\"\"\n    matrix: list[list[float]] = []\n    for element in self._elements:\n        row: list[float] = []\n        for compound in self._parsed_formulas:\n            if element in compound.keys():\n                row.append(compound[element])\n            else:\n                row.append(0.0)\n        matrix.append(row)\n    return np.array(matrix)\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator","title":"<code>reaction_validator</code>","text":""},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator","title":"<code>ReactionValidator</code>","text":"<p>               Bases: <code>Reaction</code></p> <p>Methods of this class validate the initial input reaction.</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>class ReactionValidator(Reaction):\n    \"\"\"\n    Methods of this class validate the initial input reaction.\n    \"\"\"\n\n    def _check_empty_reaction(self) -&gt; bool:\n        \"\"\"\n        Checks if reaction is an empty string.\n        \"\"\"\n        return self.reaction == \"\"\n\n    def _invalid_charachers(self) -&gt; list[str]:\n        \"\"\"\n        Checks if reaction string contains invalid characters.\n\n        Returns:\n            List of invalid characters\n        \"\"\"\n        return re.compile(self.allowed_symbols).findall(self.reaction)\n\n    def _no_reaction_separator(self) -&gt; bool:\n        \"\"\"\n        Checks if reaction string contains a separator.\n        \"\"\"\n        return self.extract_separator() == \"\"\n\n    def _no_reactant_separator(self) -&gt; bool:\n        \"\"\"\n        Checks if reaction string contains a \"+\".\n        \"\"\"\n        return self.reaction.find(self.reactant_separator) == -1\n\n    def validate_reaction(self) -&gt; bool:\n        \"\"\"\n        Validation of the reaction string.\n        Calls the private methods of this class in order.\n\n        Raise:\n            [EmptyReaction][chemsynthcalc.chem_errors.EmptyReaction] if reaction string is empty. &lt;br /&gt;\n            [InvalidCharacter][chemsynthcalc.chem_errors.InvalidCharacter] if some characters are invalid. &lt;br /&gt;\n            [NoSeparator][chemsynthcalc.chem_errors.NoSeparator] if any of separators (reaction or reactant) are missing.\n\n        Returns:\n            True if all the checks are OK\n        \"\"\"\n\n        if self._check_empty_reaction():\n            raise EmptyReaction\n        elif self._invalid_charachers():\n            raise InvalidCharacter(\n                f\"Invalid character(s) {self._invalid_charachers()} in reaction\"\n            )\n        elif self._no_reaction_separator():\n            raise NoSeparator(\n                f\"No separator between reactants and products: {self.possible_reaction_separators}\"\n            )\n        elif self._no_reactant_separator():\n            raise NoSeparator(\n                f\"No separators between compounds: {self.reactant_separator}\"\n            )\n\n        return True\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator._check_empty_reaction","title":"<code>_check_empty_reaction()</code>","text":"<p>Checks if reaction is an empty string.</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>def _check_empty_reaction(self) -&gt; bool:\n    \"\"\"\n    Checks if reaction is an empty string.\n    \"\"\"\n    return self.reaction == \"\"\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator._invalid_charachers","title":"<code>_invalid_charachers()</code>","text":"<p>Checks if reaction string contains invalid characters.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of invalid characters</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>def _invalid_charachers(self) -&gt; list[str]:\n    \"\"\"\n    Checks if reaction string contains invalid characters.\n\n    Returns:\n        List of invalid characters\n    \"\"\"\n    return re.compile(self.allowed_symbols).findall(self.reaction)\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator._no_reaction_separator","title":"<code>_no_reaction_separator()</code>","text":"<p>Checks if reaction string contains a separator.</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>def _no_reaction_separator(self) -&gt; bool:\n    \"\"\"\n    Checks if reaction string contains a separator.\n    \"\"\"\n    return self.extract_separator() == \"\"\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator._no_reactant_separator","title":"<code>_no_reactant_separator()</code>","text":"<p>Checks if reaction string contains a \"+\".</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>def _no_reactant_separator(self) -&gt; bool:\n    \"\"\"\n    Checks if reaction string contains a \"+\".\n    \"\"\"\n    return self.reaction.find(self.reactant_separator) == -1\n</code></pre>"},{"location":"API/#chemsynthcalc.reaction_validator.ReactionValidator.validate_reaction","title":"<code>validate_reaction()</code>","text":"<p>Validation of the reaction string. Calls the private methods of this class in order.</p> Raise <p>EmptyReaction if reaction string is empty.  InvalidCharacter if some characters are invalid.  NoSeparator if any of separators (reaction or reactant) are missing.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all the checks are OK</p> Source code in <code>src/chemsynthcalc/reaction_validator.py</code> <pre><code>def validate_reaction(self) -&gt; bool:\n    \"\"\"\n    Validation of the reaction string.\n    Calls the private methods of this class in order.\n\n    Raise:\n        [EmptyReaction][chemsynthcalc.chem_errors.EmptyReaction] if reaction string is empty. &lt;br /&gt;\n        [InvalidCharacter][chemsynthcalc.chem_errors.InvalidCharacter] if some characters are invalid. &lt;br /&gt;\n        [NoSeparator][chemsynthcalc.chem_errors.NoSeparator] if any of separators (reaction or reactant) are missing.\n\n    Returns:\n        True if all the checks are OK\n    \"\"\"\n\n    if self._check_empty_reaction():\n        raise EmptyReaction\n    elif self._invalid_charachers():\n        raise InvalidCharacter(\n            f\"Invalid character(s) {self._invalid_charachers()} in reaction\"\n        )\n    elif self._no_reaction_separator():\n        raise NoSeparator(\n            f\"No separator between reactants and products: {self.possible_reaction_separators}\"\n        )\n    elif self._no_reactant_separator():\n        raise NoSeparator(\n            f\"No separators between compounds: {self.reactant_separator}\"\n        )\n\n    return True\n</code></pre>"},{"location":"API/#chemsynthcalc.utils","title":"<code>utils</code>","text":"<p>A module with some useful utilities functions.</p>"},{"location":"API/#chemsynthcalc.utils.round_dict_content","title":"<code>round_dict_content(input, precision, plus=0)</code>","text":"<p>Round all values of a dictionary to arbitrary precision (with optional surplus value).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>dict[str, float]</code> <p>An input dict</p> required <code>precision</code> <code>int</code> <p>Precision</p> required <code>plus</code> <code>int</code> <p>An optional surplus</p> <code>0</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Rounded dictionary</p> Source code in <code>src/chemsynthcalc/utils.py</code> <pre><code>def round_dict_content(\n    input: dict[str, float], precision: int, plus: int = 0\n) -&gt; dict[str, float]:\n    \"\"\"\n    Round all values of a dictionary to arbitrary precision\n    (with optional surplus value).\n\n    Parameters:\n        input (dict[str, float]): An input dict\n        precision (int): Precision\n        plus (int): An optional surplus\n\n    Returns:\n        Rounded dictionary\n    \"\"\"\n    return {k: round(v, precision + plus) for k, v in input.items()}\n</code></pre>"},{"location":"API/#chemsynthcalc.utils.to_integer","title":"<code>to_integer(coefficients)</code>","text":"<p>Cast a float to int if this float is some x.0 (integer), otherwise keep a float.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>list[float | int]</code> <p>Mixed list of floats and ints</p> required <p>Returns:</p> Type Description <code>list[float | int]</code> <p>Mixed list of floats and ints</p> Source code in <code>src/chemsynthcalc/utils.py</code> <pre><code>def to_integer(coefficients: list[float | int]) -&gt; list[float | int]:\n    \"\"\"\n    Cast a float to int if this float is some x.0 (integer), otherwise\n    keep a float.\n\n    Parameters:\n        coefficients (list[float | int]): Mixed list of floats and ints\n\n    Returns:\n        Mixed list of floats and ints\n    \"\"\"\n    return [int(i) if i.is_integer() else i for i in coefficients]\n</code></pre>"},{"location":"API/#chemsynthcalc.utils.find_lcm","title":"<code>find_lcm(int_list)</code>","text":"<p>Find Least Common Multiplyer of list of integers</p> <p>Parameters:</p> Name Type Description Default <code>int_list</code> <code>list[int]</code> <p>A list of integers</p> required <p>Returns:</p> Type Description <code>int</code> <p>The LCM</p> Source code in <code>src/chemsynthcalc/utils.py</code> <pre><code>def find_lcm(int_list: list[int]) -&gt; int:\n    \"\"\"\n    Find Least Common Multiplyer of list of integers\n\n    Parameters:\n        int_list (list[int]): A list of integers\n\n    Returns:\n        The LCM\n    \"\"\"\n    lcm = 1\n    for i in int_list:\n        lcm = lcm * i // gcd(lcm, i)\n    return lcm\n</code></pre>"},{"location":"API/#chemsynthcalc.utils.find_gcd","title":"<code>find_gcd(int_list)</code>","text":"<p>Find Greatest Common Divisor of list of integers</p> <p>Parameters:</p> Name Type Description Default <code>int_list</code> <code>list[int]</code> <p>A list of integers</p> required <p>Returns:</p> Type Description <code>int</code> <p>The GCD</p> Source code in <code>src/chemsynthcalc/utils.py</code> <pre><code>def find_gcd(int_list: list[int]) -&gt; int:\n    \"\"\"\n    Find Greatest Common Divisor of list of integers\n\n    Parameters:\n        int_list (list[int]): A list of integers\n\n    Returns:\n        The GCD\n    \"\"\"\n    x = reduce(gcd, int_list)\n    return x\n</code></pre>"},{"location":"ChemicalFormula/","title":"ChemicalFormula","text":"<p>A class to represent a single chemical formula.</p> <p>API docs: ChemicalFormula</p>"},{"location":"ChemicalFormula/#formula-object-initialization","title":"Formula object initialization","text":"<p>To create a formula object from a string:</p> <pre><code>from chemsynthcalc import ChemicalFormula\n\nformula_string = \"(NH4)2SO4\"\nformula = ChemicalFormula(formula_string)\n</code></pre> <p>Important</p> <p>The symbols allowed for the ChemicalFormula input string are: a-z A-Z 0-9 . () {} [] * \u00b7 \u2022 whitespace</p> <p>Whitespaces will be ignored. If there are any other symbols in the string, they will not be ignored, instead InvalidCharacter error will be raised.</p> <p>All brackets in formula should be paired bracket-type-wise (), {}, []. If not, BracketsNotPaired error will be raised.</p> <p>Important</p> <p>Only one adduct (like X*H2O) per formula is allowed. If parser detects more than one adduct symbols (*\u00b7\u2022) it will raise MoreThanOneAdduct error.</p> <p>There is an optional rounding_order (int) parameter for rounding precision:</p> <pre><code>from chemsynthcalc import ChemicalFormula\n\nformula_string = \"(NH4)2SO4\"\nformula = ChemicalFormula(\n    formula = formula_string,\n    rounding_order = 8\n    )\n</code></pre>"},{"location":"ChemicalFormula/#formula-object-properties","title":"Formula object properties","text":"<p>After the object initialization, we can access ChemicalFormula properties:</p> <ul> <li>formula</li> <li>parsed_formula</li> <li>molar_mass</li> <li>mass_percent</li> <li>atomic_percent</li> <li>oxide_percent</li> <li>output_results</li> </ul>"},{"location":"ChemicalFormula/#custom-oxides","title":"Custom oxides","text":"<p>The oxide_percent property calculates relative percentages of oxides of  non-oxygen elements in the formula (tipycally metals). The default oxide formulas are listed in PeriodicTable. One can feed their custom oxide formulas while instantiating an object:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalFormula\n\n&gt;&gt;&gt; ChemicalFormula(\"(NH4)2SO4\").oxide_percent\n{'NO2': 37.68939937, 'H2O': 29.51742331, 'SO3': 32.79317732}\n\n&gt;&gt;&gt; ChemicalFormula(\"(NH4)2SO4\", \"S2O3\").oxide_percent\n{'NO2': 41.79831326, 'H2O': 32.73542499, 'S2O3': 25.46626175}\n</code></pre>"},{"location":"ChemicalFormula/#output","title":"Output","text":"<p>A typical ChemicalFormula results output will look like this:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalFormula\n\n&gt;&gt;&gt; ChemicalFormula(\"(NH4)2SO4\").print_results()\n\nformula: (NH4)2SO4\nparsed formula: {'N': 2.0, 'H': 8.0, 'S': 1.0, 'O': 4.0}\nmolar mass: 132.134\nmass percent: {'N': 21.2012, 'H': 6.1029, 'S': 24.2632, 'O': 48.4327}\natomic percent: {'N': 13.3333, 'H': 53.3333, 'S': 6.6667, 'O': 26.6667}\noxide percent: {'NO2': 37.6894, 'H2O': 29.5174, 'SO3': 32.7932}\n</code></pre> <p>One can output ChemicalFormula results using one of the 4 methods:</p> <ul> <li>print_results: print to stdout</li> <li>to_txt: save as plain txt file</li> <li>to_json: serialization of output into an JSON object</li> <li>to_json_file: save as JSON file</li> </ul>"},{"location":"ChemicalReaction/","title":"ChemicalReaction","text":"<p>A class to calculate end results of chemical reaction from the reaction string.</p> <p>API docs: ChemicalReaction</p>"},{"location":"ChemicalReaction/#reaction-object-initialization","title":"Reaction object initialization","text":"<p>To create a reaction object from a string:</p> <pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"Fe2O3+C=Fe3O4+FeO+Fe+Fe3C+CO+CO2\"\nreaction = ChemicalReaction(reaction_string)\n</code></pre> <p>Important</p> <p>The symbols allowed for the ChemicalReaction input string are: a-z A-Z 0-9 . () [] {} * \u00b7 \u2022 = &lt; - &gt; \u2192 \u21c4 + whitespace</p> <p>Whitespaces will be ignored. If there are any other symbols in the string, they will not be ignored, instead InvalidCharacter error will be raised.</p> <p>Important</p> <p>Other important conditions for calculations are:</p> <p>There must be one reactant-product separator (listed in possible_reaction_separators)</p> <p>The sets of atoms in the reactant and product (left-right) parts of equation should be equal (in other words, all atoms in the left must appear on the right). If not, ReactantProductDifference error will be raised.</p> <p>There are other important arguments for reaction object creation. The most important concept is calculation mode.</p>"},{"location":"ChemicalReaction/#modes","title":"Modes","text":""},{"location":"ChemicalReaction/#force-mode","title":"Force mode","text":"<p>Danger</p> <p>This mode does not imply any automatic checking of calculation results. Use it at your own risk!</p> <p>Force mode can be used when user enters coefficients in the reaction string and want masses to be calculated whether the reaction is balanced or not. For example, consider the following reaction for iodine synthesis:</p> <pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"KIO3+KI+H2SO4=I2+K2SO4+H2O\"\n</code></pre> <p>If we know beforehand that coefficient list will be [1,5,3,3,3,3], we can input:</p> <p><pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"KIO3+5KI+3H2SO4=3I2+3K2SO4+3H2O\"\nreaction = ChemicalReaction(reaction_string, mode=\"force\")\n</code></pre> We can make sure that the reaction is balanced:</p> <p><pre><code>&gt;&gt;&gt; reaction.is_balanced\nTrue\n</code></pre> And calculate the respective masses from this reaction:</p> <pre><code>&gt;&gt;&gt; reaction.masses\n[0.2810506, 1.09007501, 0.38640089, 1.0, 0.68654792, 0.07097859]\n</code></pre> <p>But what if we decided to add a 3-fold excess of KIO3? In the force mode, we can do that and still get output masses, even though the reaction is not balanced:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"3KIO3+5KI+3H2SO4=3I2+3K2SO4+3H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"force\")\n\n&gt;&gt;&gt; reaction.is_balanced\nFalse\n\n&gt;&gt;&gt; reaction.masses\n[0.84315182, 1.09007501, 0.38640089, 1.0, 0.68654792, 0.07097859]\n</code></pre> <p>As we can see, the mass of KIO3 has increased, while all other masses have not been changed.</p>"},{"location":"ChemicalReaction/#check-mode","title":"Check mode","text":"<p>Check mode is almost the same as force mode, but with mandatory reaction balance checks. Therefore, an unbalanced reaction cannot be calculated:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"3KIO3+5KI+3H2SO4=3I2+3K2SO4+3H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"check\")\n&gt;&gt;&gt; reaction.is_balanced\n\nchemsynthcalc.chem_errors.ReactionNotBalanced: This reaction is not balanced!\n</code></pre> <p>Whereas if we input the right list of coefficients: <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"3KIO3+5KI+3H2SO4=3I2+3K2SO4+3H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"check\")\n\n&gt;&gt;&gt; reaction.is_balanced\nTrue\n\n&gt;&gt;&gt; reaction.masses\n[0.2810506, 1.09007501, 0.38640089, 1.0, 0.68654792, 0.07097859]\n</code></pre></p>"},{"location":"ChemicalReaction/#balance-mode","title":"Balance mode","text":"<p>The last mode is designed for the automatic reaction balancing by means of Balancer class. It is the default mode. For most reactions, the auto balancing option is enough:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"KIO3+KI+H2SO4=I2+K2SO4+H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\")\n\n&gt;&gt;&gt; reaction.coefficients\n[1, 5, 3, 3, 3, 3]\n\n&gt;&gt;&gt; reaction.is_balanced\nTrue\n\n&gt;&gt;&gt; reaction.algorithm # we can also check which algorithm solved the reaction\ninverse\n\n&gt;&gt;&gt; reaction.masses\n[0.2810506, 1.09007501, 0.38640089, 1.0, 0.68654792, 0.07097859]\n</code></pre> <p>In some cases, however, the auto-balancing is not enough, or one would want to calculate coefficients strictly with a specific algorithm. To address these issues, the following is implemented in ChemicalReaction class logic:</p>"},{"location":"ChemicalReaction/#coefficients-property-calculation","title":"Coefficients property calculation","text":"<p>The Balancer class is designed to give high-level interface to every coefficient calculation algorithm implemented in chemsynthcalc. These can be chosen by the specific method name, and they are:</p>"},{"location":"ChemicalReaction/#inv-or-matrix-inverse-thorne-algorithm","title":"inv or matrix inverse Thorne algorithm","text":"<p>See inv_algorithm for details.</p>"},{"location":"ChemicalReaction/#gpinv-or-general-pseudoinverse-risteski-algorithm","title":"gpinv or general pseudoinverse Risteski algorithm","text":"<p>See gpinv_algorithm for details.</p>"},{"location":"ChemicalReaction/#ppinv-or-partial-pseudoinverse-risteski-algorithm","title":"ppinv or partial pseudoinverse Risteski algorithm","text":"<p>See ppinv_algorithm for details.</p>"},{"location":"ChemicalReaction/#comb-or-combinatorial-algorithm","title":"comb or combinatorial algorithm","text":"<p>See comb_algorithm for details.</p> <p>Note</p> <p>Although _intify_coefficients tries to intify coefficients, it won't always succeed. In this case, coefficients will stay float without any exception raise.</p> <p>Some examples of the same reaction balanced by these four different methods:</p> <p><pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"Fe2O3+C=Fe3O4+FeO+Fe+Fe3C+CO+CO2\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\")\n\n&gt;&gt;&gt; reaction.coefficients = reaction.balancer.inv()\n\"chemsynthcalc.chem_errors.BalancingError: Can't balance reaction by inv method\"\n</code></pre> The inverse algorithm can't handle this! Let's try others, like general pseudoinverse: <pre><code>&gt;&gt;&gt; reaction.coefficients = reaction.balancer.gpinv()\n[1954, 1854, 518, 1093, 1096, 55, 901, 898]\n</code></pre> partial pseudoinverse: <pre><code>&gt;&gt;&gt; reaction.coefficients = reaction.balancer.ppinv()\n[39, 39, 13, 13, 11, 5, 16, 18]\n</code></pre> and comb: <pre><code>&gt;&gt;&gt; reaction.coefficients = reaction.balancer.comb()\n[4, 5, 1, 1, 1, 1, 1, 3]\n</code></pre></p> <p>As we can see, we have got four different results (including 3 right ones) using four different algorithms. This is why the :meth:.ChemicalReaction.balancer.x() methods were implemented in the first place. We can, of course, get gpinv or ppinv data without intification: <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"Fe2O3+C=Fe3O4+FeO+Fe+Fe3C+CO+CO2\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\", intify=False)\n\n&gt;&gt;&gt; reaction.coefficients = reaction.balancer.gpinv()\n[1.4169688179840456, 1.3444525018129083, 0.37563451776649776, 0.7926033357505439, 0.7947788252356772, 0.03988397389412329, 0.6533720087019586, 0.6511965192168249]\n</code></pre></p> <p>Note</p> <p>Coefficients calculations by ChemicalReaction.balancer.x() methods works in all three modes (force, check and balance).</p>"},{"location":"ChemicalReaction/#coefficients-property-setter","title":"Coefficients property setter","text":"<p>Unlike other properties of ChemicalFormula and ChemicalReaction, which are programmed as read-only cached properties without setters, the coefficients property can be set directly with appropriate list of coefficients:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"KIO3+KI+H2SO4=I2+K2SO4+H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"check\")\n&gt;&gt;&gt; reaction.coefficients = [1, 5, 3, 3, 3, 3]\n\n&gt;&gt;&gt; reaction.coefficients\n[1, 5, 3, 3, 3, 3]\n\n&gt;&gt;&gt; reaction.is_balanced\nTrue\n</code></pre> <p>The coefficients_validation() method checks setted coefficients after setting them in such properties as normalized_coefficients and masses, therefore does not allow methods to calculate values with bad coefficients, for example:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"KIO3+KI+H2SO4=I2+K2SO4+H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"check\")\n&gt;&gt;&gt; reaction.coefficients = [1]\n\n&gt;&gt;&gt; reaction.coefficients\n[1]\n\n&gt;&gt;&gt; reaction.is_balanced\nFalse\n\n&gt;&gt;&gt; reaction.masses\nchemsynthcalc.chem_errors.BadCoeffiecients: Number of coefficients should be equal to 6\n</code></pre> <p>This is one more way (along with direct input of coefficients in the reaction string for force and check modes) to input a custom set of coefficients for a particular reaction.</p> <p>Note</p> <p>Coefficients setting works in all three modes (force, check and balance).</p> <p>Now, when we covered modes and coefficients property calculations, we can get back to other arguments for reaction object creation.</p>"},{"location":"ChemicalReaction/#target","title":"Target","text":"<p>The \"target\" parameter is the target chemical synthesis substance (i.e., whose mass is known in advance). The target choice is implemented as an integer pointer to formula index in products (right side of equation). There are, of course, other ways to do this (like explicitly input target as formula string), but integer index target was chose as method less prone to errors. Most of the time the target of the synthesis is the first product anyway (which is equal to 0 by default). We can set a target with object instantiation (the target is 1 which is FeO):</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"Fe2O3+C=Fe3O4+FeO+Fe+Fe3C+CO+CO2\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\", target=1)\n\n&gt;&gt;&gt; reaction.masses\n[3.97359366, 0.28358172, 1.52731369, 1.0, 0.77944268, 0.12575572, 0.32138621, 0.5032771]\n</code></pre> <p>If we change the target, masses will obviously change too:</p> <pre><code>&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\", target=2)\n\n&gt;&gt;&gt; reaction.masses\n[5.09799345, 0.36382626, 1.95949455, 1.28296797, 1.0, 0.16134056, 0.41232821, 0.64568841]\n</code></pre> <p>The target can also be negative (limiting compoud - C in that case):</p> <pre><code>&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\", target=-1)\n\n&gt;&gt;&gt; reaction.masses\n[14.01216438, 1.0, 5.38579736, 3.52632041, 2.74856462, 0.443455, 1.13331074, 1.77471629]\n</code></pre>"},{"location":"ChemicalReaction/#target-mass","title":"Target mass","text":"<p>The mass of target compound, the only mass that we know in advance before synthesis (in grams). We can change the target mass during the ChemicalReaction object instantiation (1 gram is the default):</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"Fe2O3+C=Fe3O4+FeO+Fe+Fe3C+CO+CO2\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string, mode=\"balance\", target=1, target_mass=2)\n\n&gt;&gt;&gt; reaction.masses\n[7.94718732, 0.56716344, 3.05462737, 2.0, 1.55888536, 0.25151145, 0.64277241, 1.0065542]\n</code></pre>"},{"location":"ChemicalReaction/#chemicalreaction-properties","title":"ChemicalReaction properties","text":"<p>After the object initialization, we can access the ChemicalReaction properties:</p> <ul> <li>reaction</li> <li>decomposed_reaction</li> <li>_calculated_target</li> <li>chemformula_objs</li> <li>parsed_formulas</li> <li>matrix</li> <li>balancer</li> <li>molar_masses</li> <li>coefficients</li> <li>normalized_coefficients</li> <li>is_balanced</li> <li>final_reaction</li> <li>final_reaction_normalized</li> <li>masses</li> <li>output_results</li> </ul>"},{"location":"ChemicalReaction/#output","title":"Output","text":"<p>A typical ChemicalReaction results output will look like this:</p> <pre><code>&gt;&gt;&gt; from chemsynthcalc import ChemicalReaction\n\n&gt;&gt;&gt; reaction_string = \"KIO3+KI+H2SO4=I2+K2SO4+H2O\"\n&gt;&gt;&gt; reaction = ChemicalReaction(reaction_string)\n&gt;&gt;&gt; reaction.print_results()\n\ninitial reaction: KIO3+KI+H2SO4=I2+K2SO4+H2O\nreaction matrix:\n [[1. 1. 0. 0. 2. 0.]\n [1. 1. 0. 2. 0. 0.]\n [3. 0. 4. 0. 4. 1.]\n [0. 0. 2. 0. 0. 2.]\n [0. 0. 1. 0. 1. 0.]]\nmode: balance\nformulas: ['KIO3', 'KI', 'H2SO4', 'I2', 'K2SO4', 'H2O']\ncoefficients: [1, 5, 3, 3, 3, 3]\nnormalized coefficients: [0.33333333, 1.66666667, 1, 1, 1, 1]\nalgorithm: inverse\nis balanced: True\nfinal reaction: KIO3+5KI+3H2SO4=3I2+3K2SO4+3H2O\nfinal reaction normalized: 0.33333333KIO3+1.66666667KI+H2SO4=I2+K2SO4+H2O\nmolar masses: [213.99947, 166.00247, 98.072, 253.80894, 174.252, 18.015]\ntarget: I2\nmasses: [0.2811, 1.0901, 0.3864, 1.0, 0.6865, 0.071]\nKIO3: M = 213.9995 g/mol, m = 0.2811 g\nKI: M = 166.0025 g/mol, m = 1.0901 g\nH2SO4: M = 98.0720 g/mol, m = 0.3864 g\nI2: M = 253.8089 g/mol, m = 1.0000 g\nK2SO4: M = 174.2520 g/mol, m = 0.6865 g\nH2O: M = 18.0150 g/mol, m = 0.0710 g\n</code></pre> <p>One can output ChemicalReaction results using one of the 4 methods:</p> <ul> <li>print_results: print to stdout</li> <li>to_txt: save as plain txt file</li> <li>to_json: serialization of output into an JSON object</li> <li>to_json_file: save as JSON file</li> </ul>"},{"location":"contacts/","title":"Contacts","text":"<p>If you have any questions, please contact Egor Syrov at syrov_ev@mail.ru or create an issue at github.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python","title":"Python","text":"<p>chemsynthacalc requires Python 3.10 or later.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>Install from pypi:</p> <pre><code>pip install chemsynthcalc\n</code></pre>"},{"location":"installation/#numpy-and-scipy","title":"NumPy and SciPy","text":"<p>NumPy and SciPy are requirements for fast matrix operations for reaction balancing. They will be installed automatically by pip if they are not already installed.</p>"},{"location":"installation/#but-why-chemsynthcalc-is-using-scipy","title":"But why chemsynthcalc is using SciPy?","text":"<p>In short: to ensure consistent results across all platforms. See Note on SciPy.</p>"},{"location":"usage/","title":"Usage","text":"<p>Let's say that we need to prepare 3 grams of YBCO by solid-state synthesis from respective carbonates.</p>"},{"location":"usage/#reaction-string","title":"Reaction string","text":"<pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"BaCO3 + Y2(CO3)3 + CuCO3 + O2 \u2192 YBa2Cu3O7 + CO2\"\n</code></pre>"},{"location":"usage/#chemicalreaction-object","title":"ChemicalReaction object","text":"<p>Now, we can create a chemical reaction object of ChemicalReaction class, which will be used in the calculation. We need to specify arguments for our particular case: <pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"BaCO3 + Y2(CO3)3 + CuCO3 + O2 \u2192 YBa2Cu3O7 + CO2\"\n\nreaction = ChemicalReaction(\n    reaction = reaction_string, # our reaction string\n    target = 0, # number of target compound in product list\n    target_mass = 3, # desired mass of target compound,\n    mode = \"balance\" # mode of coefficients calculations,\n)\n</code></pre></p>"},{"location":"usage/#calculation-and-output","title":"Calculation and output","text":"<p>Now, to perform automatic calculation, all we need to do is to put print_results() method: <pre><code>from chemsynthcalc import ChemicalReaction\n\nreaction_string = \"BaCO3 + Y2(CO3)3 + CuCO3 + O2 \u2192 YBa2Cu3O7 + CO2\"\n\nreaction = ChemicalReaction(\n    reaction = reaction_string, # our reaction string\n    target = 0, # number of target compound in product list\n    target_mass = 3, # desired mass of target compound,\n    mode = \"balance\" # mode of coefficients calculations,\n)\n\nreaction.print_results(print_rounding_order=4)\n# assuming we use analytical balances with 4 digits presicion\n</code></pre></p> <p>And we get our ouput in the terminal:</p> <pre><code>initial reaction: BaCO3+Y2(CO3)3+CuCO3+O2\u2192YBa2Cu3O7+CO2\nreaction matrix:\n [[1. 0. 0. 0. 2. 0.]\n [1. 3. 1. 0. 0. 1.]\n [3. 9. 3. 2. 7. 2.]\n [0. 2. 0. 0. 1. 0.]\n [0. 0. 1. 0. 3. 0.]]\nmode: balance\nformulas: ['BaCO3', 'Y2(CO3)3', 'CuCO3', 'O2', 'YBa2Cu3O7', 'CO2']\ncoefficients: [8, 2, 12, 1, 4, 26]\nnormalized coefficients: [2, 0.5, 3, 0.25, 1, 6.5]\nalgorithm: inverse\nis balanced: True\nfinal reaction: 8BaCO3+2Y2(CO3)3+12CuCO3+O2\u21924YBa2Cu3O7+26CO2\nfinal reaction normalized: 2BaCO3+0.5Y2(CO3)3+3CuCO3+0.25O2\u2192YBa2Cu3O7+6.5CO2\nmolar masses: [197.335, 357.835676, 123.554, 31.998, 666.190838, 44.009]\ntarget: YBa2Cu3O7\nmasses: [1.7773, 0.8057, 1.6692, 0.036, 3.0, 1.2882]\nBaCO3: M = 197.3350 g/mol, m = 1.7773 g\nY2(CO3)3: M = 357.8357 g/mol, m = 0.8057 g\nCuCO3: M = 123.5540 g/mol, m = 1.6692 g\nO2: M = 31.9980 g/mol, m = 0.0360 g\nYBa2Cu3O7: M = 666.1908 g/mol, m = 3.0000 g\nCO2: M = 44.0090 g/mol, m = 1.2882 g\n</code></pre> <p>Thus, we got all masses ready for our planned synthesis!</p>"}]}